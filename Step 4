#!/usr/bin/env python3
"""
Luna HSM User Creation and Role Import Script (Version-Aware, SCP-based)

Purpose:
    Automates creation of a LunaSH user-management role and user on a Luna Network HSM.

Key Features:
    • Reads HSM connection details from resources/hsm_mapping.json
    • Prompts for admin credentials
    • Connects via SSH
    • Detects Luna firmware version and maps it to the correct role command set
    • Generates an appropriate role file (in /tmp) and uploads it via scp -O
    • Imports the role and assigns it to the created user
    • Leaves the uploaded role file on the HSM for reference
    • Displays a clear summary of detected version and actions performed
"""

import argparse
import os
import json
import datetime
import secrets
import string
import subprocess
import getpass
import socket
import re
from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException

# ----------------------------------------------------------------------
# Constants and file paths
# ----------------------------------------------------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
PW_STORE = os.path.join(RES_DIR, "user_passwords.json")
os.makedirs(RES_DIR, exist_ok=True)

# ----------------------------------------------------------------------
# Role command definitions per firmware group
# ----------------------------------------------------------------------
# These sets are derived from official Thales documentation.
# Each minor version range shares identical user-management command behavior.
#
# Group 7.3 → covers 7.3, 7.4, 7.5, 7.6
# Group 7.7 → covers 7.7, 7.8
# Group 7.9 → covers 7.9, 7.10, 7.11, and 8.x (future-compatible)
#
# Fallback → used only if firmware version cannot be detected.
ROLE_DEFINITIONS = {
    "7.3": [
        "user list", "user add", "user delete", "user enable", "user disable",
        "user password", "user role add", "user role delete",
        "user role clear", "user role list", "user role import"
    ],
    "7.7": [
        "user list", "user add", "user delete", "user enable", "user disable",
        "user password", "user radiusAdd",
        "user role add", "user role delete",
        "user role list", "user role import"
    ],
    "7.9": [
        "user list", "user add", "user delete", "user enable", "user disable",
        "user password", "user radiusAdd", "user radiusDelete",
        "user role add", "user role delete",
        "user role list", "user role import"
    ]
}

FALLBACK_ROLE = [
    "user list", "user add", "user delete", "user password",
    "user role list", "user role import"
]

# ----------------------------------------------------------------------
# Utility helpers
# ----------------------------------------------------------------------
def ssh_run(client, cmd, timeout=10, input_text=None):
    """Execute a command on the HSM over SSH and return (stdout, stderr, exit_code)."""
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    if input_text:
        stdin.write(input_text)
        stdin.flush()
    out, err = stdout.read().decode(errors="ignore"), stderr.read().decode(errors="ignore")
    rc = stdout.channel.recv_exit_status()
    return out, err, rc

def load_hsm(hsm_id):
    """Load HSM connection details (host, port) from JSON mapping file."""
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in mapping.")

def _generate_temp_password(length=16):
    """Generate a secure random temporary password for the new user."""
    alphabet = string.ascii_letters + string.digits + "._-"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def _save_password_for_user(username, password):
    """Persist generated passwords locally in resources/user_passwords.json."""
    data = {}
    if os.path.exists(PW_STORE):
        try:
            with open(PW_STORE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            data = {}
    data[username] = {"password": password, "created_at": datetime.datetime.utcnow().isoformat() + "Z"}
    tmp = PW_STORE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, PW_STORE)
    try:
        os.chmod(PW_STORE, 0o600)
    except Exception:
        pass

# ----------------------------------------------------------------------
# Version detection logic
# ----------------------------------------------------------------------
def detect_luna_version(client):
    """
    Detect Luna firmware version and map it to a known behavior group.

    It runs multiple candidate commands since output format varies by version.
    Example version strings: "7.7.1", "Firmware Version: 7.3.0"

    Returns: '7.3', '7.7', '7.9', or '' (fallback).
    """
    candidates = ["version", "show version", "hsm version", "system show version", "hsm show"]
    text = ""
    for cmd in candidates:
        out, err, rc = ssh_run(client, cmd, timeout=8)
        combo = (out + err).strip().lower()
        if not combo or "permission denied" in combo:
            continue
        if re.search(r"\d+\.\d+", combo):
            text = combo
            break

    if not text:
        print("[WARN] Could not read version output. Using fallback role.")
        return ""

    match = re.search(r"(\d+)\.(\d+)(?:\.(\d+))?", text)
    if not match:
        return ""

    major, minor = int(match.group(1)), int(match.group(2))

    # Map firmware version to the corresponding role group
    if major == 7 and minor in (3, 4, 5, 6):
        return "7.3"
    if major == 7 and minor in (7, 8):
        return "7.7"
    if (major == 7 and minor >= 9) or major >= 8:
        return "7.9"
    return ""

# ----------------------------------------------------------------------
# Core Luna operations
# ----------------------------------------------------------------------
def make_role_file(lines, role_name):
    """Write a temporary role file to /tmp for SCP transfer."""
    path = f"/tmp/{role_name}.txt"
    with open(path, "w", encoding="utf-8", newline="\n") as f:
        for l in lines:
            f.write(l.rstrip() + "\n")
    return path

def scp_upload(host, user, local_path, remote_name):
    """Upload the generated role file to the HSM using the OpenSSH scp client."""
    cmd = f'scp -O "{local_path}" {user}@{host}:{remote_name}'
    print(f"[INFO] Uploading role file '{remote_name}' to HSM via scp...")
    result = subprocess.run(cmd, shell=True)
    if result.returncode == 0:
        print("[INFO] Upload successful.")
        return True
    print(f"[ERROR] scp failed (rc={result.returncode})")
    return False

def create_user(client, username):
    """Create a new LunaSH user and store its temporary password."""
    temp_pw = _generate_temp_password()
    cmd = f"user add -username {username}"
    out, err, rc = ssh_run(client, cmd, input_text=f"{temp_pw}\n{temp_pw}\n", timeout=60)
    if rc != 0 or "error" in (out + err).lower():
        print(f"[ERROR] Failed to create user:\n{out+err}")
        return None
    _save_password_for_user(username, temp_pw)
    print(f"[INFO] User '{username}' created successfully.")
    return temp_pw

def import_and_assign(client, username, remote_file, role_name):
    """Import the uploaded role file and assign it to the newly created user."""
    cmds = [
        f"user role import -file {remote_file} -role {role_name}",
        f"user role import -role {role_name} -file {remote_file}",
        f"user role import {remote_file}"
    ]
    for c in cmds:
        out, err, rc = ssh_run(client, c, timeout=30)
        combo = (out + err).lower()
        if rc == 0 and "error" not in combo and "unknown" not in combo:
            print(f"[INFO] Role import succeeded using: {c}")
            break
    else:
        print(f"[ERROR] Role import failed:\n{out+err}")
        return False

    out, err, rc = ssh_run(client, f"user role add -username {username} -role {role_name}", timeout=25)
    if rc == 0 and "error" not in (out + err).lower():
        print(f"[INFO] Role '{role_name}' assigned to '{username}'.")
        return True
    print(f"[ERROR] Failed to assign role:\n{out+err}")
    return False

# ----------------------------------------------------------------------
# Main execution flow
# ----------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--hsm-id", required=True)
    args = parser.parse_args()

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))

    admin_user = input("Username: ").strip()
    admin_pwd = getpass.getpass("Password: ")

    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())

    try:
        print(f"[INFO] Connecting to {host}:{port}...")
        client.connect(hostname=host, port=port,
                       username=admin_user, password=admin_pwd,
                       allow_agent=False, look_for_keys=False, timeout=20)
    except (AuthenticationException, SSHException, socket.error) as e:
        print(f"[ERROR] SSH connection failed: {e}")
        return

    # Detect HSM version and select appropriate command set
    tag = detect_luna_version(client)
    role_lines = ROLE_DEFINITIONS.get(tag, FALLBACK_ROLE)
    role_name = f"user_mgmt_role_{tag or 'fallback'}"
    remote_file = f"{role_name}.txt"

    print(f"\n[SUMMARY] Detected Luna firmware group: {tag or 'fallback'}")
    print(f"[SUMMARY] Role file: {remote_file}")
    print(f"[SUMMARY] Role name: {role_name}\n")

    # Create temporary local file for SCP transfer
    local_path = make_role_file(role_lines, role_name)
    if not scp_upload(host, admin_user, local_path, remote_file):
        client.close()
        return
    os.remove(local_path)

    # Create new user and assign imported role
    new_user = input("Enter new username: ").strip()
    pw = create_user(client, new_user)
    if not pw:
        client.close()
        return

    if import_and_assign(client, new_user, remote_file, role_name):
        print(f"\n✅ [SUCCESS] Role '{role_name}' imported and assigned to '{new_user}'.")
    else:
        print("\n❌ [ERROR] Role import or assignment failed.")

    # Validate HSM communication
    _, _, rc = ssh_run(client, "hsm show", timeout=20)
    print("[INFO] HSM connectivity verified." if rc == 0 else "[WARN] hsm show returned non-zero.")

    # Final summary
    print(f"\n[SUMMARY] Version detected: {tag or 'fallback'} → Role file '{remote_file}' used for assignment.\n")

    client.close()

if __name__ == "__main__":
    main()
