#!/usr/bin/env python3
"""
user_mgmt.py

Hardened, self-bootstrap script to create a user+role on Luna HSMs.

Notes:
 - Installs missing Python packages (asyncssh, portalocker, requests) via pip at runtime.
 - Uses asyncssh for LunaSH interactions (SFTP + PTY).
 - Uses requests for REST API calls (no curl dependency).
 - Reads resources/hsm_mapping.json and resources/version_map.json
 - Role files expected under resources/roles/<role-file>
"""

import sys
import subprocess
import importlib
import os
import json
import asyncio
import secrets
import string
import random
import getpass
import base64
import time
import shlex

# ----------------------------
# Ensure runtime Python packages
# ----------------------------
REQUIRED = ("asyncssh", "portalocker", "requests")
for pkg in REQUIRED:
    try:
        importlib.import_module(pkg)
    except Exception:
        print(f"[INFO] Installing missing package: {pkg}")
        subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])
# now import them
import asyncssh
import portalocker
import requests

# ----------------------------
# Config
# ----------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
VERSION_FILE = os.path.join(RES_DIR, "version_map.json")
ROLES_DIR = os.path.join(RES_DIR, "roles")
FAILED_LOG = os.path.join(RES_DIR, "failed_jobs.jsonl")
DEFAULT_ROLE_FILE = "user_mgmt_role.txt"

SSH_RETRIES = 3
BACKOFF_BASE = 0.5
BACKOFF_FACTOR = 2.0
BACKOFF_JITTER = 0.2
DEFAULT_REST_PORT = 8443

# ----------------------------
# Helpers
# ----------------------------
def load_json(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def check_fw_version(v, cmp_to="7.8.0"):
    if not v:
        return False
    def parse(s):
        s = s.split("-")[0]
        return tuple(int(x) for x in s.split("."))
    try:
        return parse(v) >= parse(cmp_to)
    except Exception:
        return False

def gen_username():
    return "usermgmt_" + secrets.token_hex(3)

def gen_password(length=16):
    chars = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    while True:
        p = ''.join(secrets.choice(chars) for _ in range(length))
        if (any(c.islower() for c in p) and any(c.isupper() for c in p)
                and any(c.isdigit() for c in p) and any(c in "!@#$%^&*()-_=+" for c in p)):
            return p

async def backoff_sleep(attempt):
    base = BACKOFF_BASE * (BACKOFF_FACTOR ** (attempt - 1))
    jitter = random.uniform(-BACKOFF_JITTER, BACKOFF_JITTER)
    await asyncio.sleep(max(0, base + jitter))

def write_failed(entry):
    os.makedirs(os.path.dirname(FAILED_LOG), exist_ok=True)
    with portalocker.Lock(FAILED_LOG, mode="a", timeout=5) as fh:
        fh.write(json.dumps(entry) + "\n")

def get_content_type_token(version_map, fw_version):
    token = version_map.get(fw_version)
    if token is None:
        raise KeyError(f"Firmware version '{fw_version}' not found in {VERSION_FILE}")
    return token

# ----------------------------
# asyncssh connect helper
# ----------------------------
async def connect_password_flexible(host, port, username, password, timeout=20):
    """
    Try several asyncssh.connect argument combinations to be flexible with remote servers.
    Important: do NOT pass 'term_type' to asyncssh.connect (that's invalid).
    We also set known_hosts=None to skip host key verification (since many appliances use transient host keys).
    If you want strict host key checking, remove known_hosts=None and configure known hosts on the runner.
    """
    last_exc = None
    candidates = [
        {"username": username, "password": password, "known_hosts": None, "client_keys": None, "allow_agent": False, "look_for_keys": False},
        {"username": username, "password": password, "known_hosts": None, "client_keys": None},
        {"username": username, "password": password, "known_hosts": None},
        {"username": username, "password": password},
    ]
    for args in candidates:
        try:
            conn = await asyncio.wait_for(asyncssh.connect(host, port=port, **args), timeout=timeout)
            return conn
        except Exception as e:
            last_exc = e
            # try next
            continue
    raise last_exc

# ----------------------------
# PTY-based command runner for LunaSH
# ----------------------------
async def run_with_pty(conn, cmd, input_text=None, prompt="lunash>", timeout=20):
    """
    Run a command via PTY and return (stdout_text, stderr_text, rc_or_None).
    Uses conn.create_process(term_type=...) — here term_type is passed to create_process, not connect.
    Handles decoding bytes to text and waits for the prompt or timeout.
    """
    proc = await conn.create_process(term_type="xterm")
    try:
        # send any initial input first (e.g., when command expects interactive input)
        if input_text is not None:
            if isinstance(input_text, str):
                input_bytes = input_text.encode()
            else:
                input_bytes = input_text
            try:
                proc.stdin.write(input_bytes)
                await proc.stdin.drain()
            except Exception:
                pass

        # send the command
        try:
            proc.stdin.write((cmd + "\n").encode())
            await proc.stdin.drain()
        except Exception:
            pass

        out = ""
        start = time.time()
        while True:
            try:
                chunk = await asyncio.wait_for(proc.stdout.read(1024), timeout=2)
            except asyncio.TimeoutError:
                chunk = b""
            if chunk:
                if isinstance(chunk, bytes):
                    part = chunk.decode(errors="ignore")
                else:
                    part = str(chunk)
                out += part
                if prompt and prompt.lower() in out.lower():
                    break
            if (time.time() - start) > timeout:
                break

        # read stderr non-blocking
        err = ""
        try:
            while True:
                chunk = await asyncio.wait_for(proc.stderr.read(1024), timeout=0.1)
                if not chunk:
                    break
                if isinstance(chunk, bytes):
                    err += chunk.decode(errors="ignore")
                else:
                    err += str(chunk)
        except asyncio.TimeoutError:
            pass

        rc = getattr(proc, "exit_status", None)
        return out, err, rc
    finally:
        try:
            proc.close()
        except Exception:
            pass

# ----------------------------
# LunaSH functions
# ----------------------------
async def lunash_check_webserver(hsm, ssh_user, ssh_pass):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    try:
        conn = await connect_password_flexible(host, port, ssh_user, ssh_pass)
        async with conn:
            out, err, _ = await run_with_pty(conn, "webserver show", timeout=10)
            combined = (out or "") + (err or "")
            return "running" in combined.lower()
    except Exception:
        return False

async def lunash_setup(hsm, ssh_user, ssh_pass, role_file, user, pwd):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    local_role = os.path.join(ROLES_DIR, role_file)
    if not os.path.exists(local_role):
        raise FileNotFoundError(f"Local role file not found: {local_role}")
    role_name = os.path.splitext(os.path.basename(local_role))[0]
    remote_role = f"/tmp/{os.path.basename(local_role)}"

    conn = await connect_password_flexible(host, port, ssh_user, ssh_pass)
    try:
        async with conn:
            uploaded = False
            # 1) Try SFTP
            try:
                async with conn.start_sftp_client() as sftp:
                    await sftp.put(local_role, remote_role)
                    uploaded = True
            except Exception:
                uploaded = False

            # 2) Fallback: base64 chunked upload via printf
            if not uploaded:
                try:
                    b64 = base64.b64encode(open(local_role, "rb").read()).decode()
                    remote_b64 = f"/tmp/{os.path.basename(local_role)}.b64"
                    await conn.run(f"rm -f {shlex.quote(remote_b64)}", check=False)
                    chunk_size = 1400
                    for i in range(0, len(b64), chunk_size):
                        chunk = b64[i:i+chunk_size]
                        # printf safely appends chunk
                        cmd = f"printf '%s' {shlex.quote(chunk)} >> {shlex.quote(remote_b64)}"
                        await conn.run(cmd, check=False)
                    await conn.run(f"base64 -d {shlex.quote(remote_b64)} > {shlex.quote(remote_role)}", check=False)
                    await conn.run(f"rm -f {shlex.quote(remote_b64)}", check=False)
                    uploaded = True
                except Exception as e:
                    print(f"[{hsm.get('id')}] role upload fallback failed: {e}")
                    uploaded = False

            if not uploaded:
                raise RuntimeError("Role upload failed")

            # run LunaSH commands
            cmds = [
                f"user role import {role_name} {remote_role}",
                f"user add -userName {user} -password {pwd}",
                f"user role add {user} {role_name}",
            ]
            for c in cmds:
                out, err, rc = await run_with_pty(conn, c, timeout=25)
                combined = (out or "") + (err or "")
                lower = combined.lower()
                if "permission denied" in lower or "not authorized" in lower:
                    raise RuntimeError(f"LunaSH permission problem: {combined.strip()}")
                if "syntax error" in lower or "not recognized" in lower:
                    raise RuntimeError(f"LunaSH syntax problem: {combined.strip()}")

            # ensure password set (some firmwares require the interactive command)
            pw_input = f"{pwd}\n{pwd}\n"
            out, err, rc = await run_with_pty(conn, f"user password -userName {user}", input_text=pw_input, timeout=20)
            combined = (out or "") + (err or "")
            if "permission denied" in combined.lower():
                raise RuntimeError(f"Setting password failed: {combined.strip()}")

            out, err, rc = await run_with_pty(conn, "user list", timeout=15)
            users_out = (out or "") + (err or "")
            return user in users_out
    finally:
        try:
            conn.close()
        except Exception:
            pass

async def test_ssh_one(hsm, ssh_user, ssh_pass):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    try:
        conn = await connect_password_flexible(host, port, ssh_user, ssh_pass)
        async with conn:
            out, err, _ = await run_with_pty(conn, "user list", timeout=10)
            snippet = ((out or "") + (err or ""))[:400]
            print(f"[{hsm.get('id')} | {host}] snippet:\n{snippet}")
            return True, None
    except Exception as e:
        return False, str(e)

# ----------------------------
# REST helpers using requests
# ----------------------------
def build_rest_session(base_url, admin_user, admin_pass, ct, insecure):
    """
    Returns (requests.Session(), session_id_cookie)
    """
    sess = requests.Session()
    sess.verify = not insecure
    sess.headers.update({"Content-Type": ct})
    # Basic auth for the POST /auth/session
    url = base_url.rstrip("/") + "/auth/session"
    # some Luna docs use trailing slash — requests handles both
    r = sess.post(url, auth=(admin_user, admin_pass), timeout=20)
    # expect 2xx and a SESSION_ID cookie
    if r.status_code < 200 or r.status_code >= 300:
        raise RuntimeError(f"REST login failed (HTTP {r.status_code}): {r.text[:400]}")
    # cookie name may be SESSION_ID
    sid = None
    if "SESSION_ID" in r.cookies:
        sid = r.cookies.get("SESSION_ID")
    else:
        # try Set-Cookie header parsing as fallback
        sc = r.headers.get("Set-Cookie", "")
        if "SESSION_ID=" in sc:
            try:
                sid = sc.split("SESSION_ID=")[1].split(";")[0].strip()
            except Exception:
                sid = None
    if not sid:
        raise RuntimeError(f"REST login did not return SESSION_ID cookie. Headers: {r.headers}")
    sess.cookies.set("SESSION_ID", sid)
    return sess, sid

def rest_create_role(sess, base_url, role, insecure):
    url = base_url.rstrip("/") + "/roles"
    payload = {"roleId": role}
    r = sess.post(url, json=payload, timeout=20)
    return r.status_code

def rest_put_rolefile(sess, base_url, role, role_file_path, ct_file, insecure):
    url = base_url.rstrip("/") + f"/roles/{role}/resources"
    with open(role_file_path, "rb") as fh:
        headers = {"Content-Type": ct_file}
        r = sess.put(url, data=fh.read(), headers=headers, timeout=30)
    return r.status_code

def rest_create_user(sess, base_url, user, pwd, role, insecure):
    url = base_url.rstrip("/") + "/users"
    payload = {"userId": user, "role": role, "password": pwd}
    r = sess.post(url, json=payload, timeout=20)
    return r.status_code

def rest_get_users(sess, base_url, insecure):
    url = base_url.rstrip("/") + "/users"
    r = sess.get(url, timeout=20)
    return r.status_code, r.text

# ----------------------------
# Orchestration per HSM
# ----------------------------
async def process_hsm(hsm, admin_user, admin_pass, role_file, version_map, insecure, test_ssh_only=False, skip_webserver=False, ssh_user=None, ssh_pass=None):
    hid = hsm.get("id")
    fw = hsm.get("fwVersion")
    host = hsm.get("ipAddress") or hsm.get("host") or "<no-host>"

    try:
        token = get_content_type_token(version_map, fw)
    except KeyError as e:
        print(f"[{hid}] Version map error: {e}")
        write_failed({"hsm_id": hid, "stage": "version-map", "error": str(e)})
        return {"hsm": hid, "status": "FAILED"}

    ct_json = f"application/vnd.safenetinc.lunasa+json;version={token}"
    ct_file = f"application/vnd.safenetinc.lunasa+file;version={token}"
    print(f"[{hid} | {host}] fw={fw} -> REST v{token}")

    ssh_user = ssh_user or admin_user
    ssh_pass = ssh_pass or admin_pass

    if test_ssh_only:
        ok = False
        last_err = None
        for attempt in range(1, SSH_RETRIES + 1):
            ok, last_err = await test_ssh_one(hsm, ssh_user, ssh_pass)
            if ok:
                break
            print(f"[{hid}] SSH test attempt {attempt} failed: {last_err}")
            if attempt < SSH_RETRIES:
                await backoff_sleep(attempt)
        if not ok:
            write_failed({"hsm_id": hid, "stage": "ssh-test", "error": last_err})
            return {"hsm": hid, "status": "SSH-FAILED", "error": last_err}
        return {"hsm": hid, "status": "SSH-OK"}

    user, pwd = gen_username(), gen_password()
    base = hsm.get("rest_url") or f"https://{host}:{DEFAULT_REST_PORT}"

    if not skip_webserver:
        ok = False
        last_err = None
        for attempt in range(1, SSH_RETRIES + 1):
            try:
                if await lunash_check_webserver(hsm, ssh_user, ssh_pass):
                    ok = True
                    break
            except Exception as e:
                last_err = str(e)
            print(f"[{hid}] Webserver check attempt {attempt} failed: {last_err if last_err else 'error'}")
            if attempt < SSH_RETRIES:
                await backoff_sleep(attempt)
        if not ok:
            print(f"[{hid}] Webserver check failed (via LunaSH)")
            write_failed({"hsm_id": hid, "stage": "webserver", "error": "Webserver not running (LunaSH)"})
            return {"hsm": hid, "status": "FAILED"}

    # If old firmware: use LunaSH to create role/user (pre-REST sync)
    if not check_fw_version(fw):
        ok = False
        last_err = None
        for attempt in range(1, SSH_RETRIES + 1):
            try:
                res = await lunash_setup(hsm, ssh_user, ssh_pass, role_file, user, pwd)
                if res:
                    ok = True
                    break
            except Exception as e:
                last_err = str(e)
                print(f"[{hid}] LunaSH setup attempt {attempt} failed: {last_err}")
            if attempt < SSH_RETRIES:
                await backoff_sleep(attempt)
        if not ok:
            write_failed({"hsm_id": hid, "stage": "lunash", "error": last_err})
            return {"hsm": hid, "status": "FAILED"}

    # REST flow (create role, upload role file, create user)
    try:
        sess, sid = build_rest_session(base, admin_user, admin_pass, ct_json, insecure)
        role_name = os.path.splitext(role_file)[0]
        rc = rest_create_role(sess, base, role_name, insecure)
        if rc not in (200,201,204,409):
            raise RuntimeError(f"Role create failed (HTTP {rc})")
        role_file_path = os.path.join(ROLES_DIR, role_file)
        if not os.path.exists(role_file_path):
            raise FileNotFoundError(f"Role file not found locally: {role_file_path}")
        rc = rest_put_rolefile(sess, base, role_name, role_file_path, ct_file, insecure)
        if rc not in (200,201,204):
            raise RuntimeError(f"Role upload failed (HTTP {rc})")
        rc = rest_create_user(sess, base, user, pwd, role_name, insecure)
        if rc not in (200,201,204):
            raise RuntimeError(f"User create failed (HTTP {rc})")
        rc_get, out = rest_get_users(sess, base, insecure)
        if user not in out:
            return {"hsm": hid, "status": "WARN", "user": user, "password": pwd}
    except Exception as e:
        print(f"[{hid}] REST error: {e}")
        write_failed({"hsm_id": hid, "stage": "rest", "error": str(e)})
        return {"hsm": hid, "status": "FAILED"}

    return {"hsm": hid, "status": "OK", "user": user, "password": pwd, "note": "password will be forced to change at first login"}

# ----------------------------
# Runner
# ----------------------------
async def run_all(hsm_ids, admin_user, admin_pass, role_file, insecure, test_ssh_only=False, skip_webserver=False, ssh_user=None, ssh_pass=None):
    hsms = load_json(HSM_FILE).get("hsms", [])
    version_map = load_json(VERSION_FILE)
    lookup = {h["id"]: h for h in hsms}
    tasks = []
    for hid in hsm_ids:
        if hid not in lookup:
            print(f"[SKIP] {hid} not found in {HSM_FILE}")
            continue
        tasks.append(process_hsm(lookup[hid], admin_user, admin_pass, role_file, version_map, insecure, test_ssh_only, skip_webserver, ssh_user, ssh_pass))
    return await asyncio.gather(*tasks)

def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--hsm-ids", nargs="+", required=True)
    parser.add_argument("--admin-user", required=True)
    parser.add_argument("--role-file", default=DEFAULT_ROLE_FILE)
    parser.add_argument("--insecure", action="store_true")
    parser.add_argument("--dry-run", action="store_true", help="Show what would happen, but do nothing")
    parser.add_argument("--test-ssh", action="store_true", help="Only test SSH auth/connectivity and exit")
    parser.add_argument("--skip-webserver", action="store_true", help="Skip webserver check (LunaSH) and proceed")
    parser.add_argument("--ssh-user", help="SSH username if different from admin-user")
    parser.add_argument("--ssh-pass", help="SSH password if different (optional)")
    args = parser.parse_args()

    admin_pass = getpass.getpass("Admin password: ")
    ssh_pass = args.ssh_pass or admin_pass

    if args.dry_run:
        hsms = load_json(HSM_FILE).get("hsms", [])
        version_map = load_json(VERSION_FILE)
        lookup = {h["id"]: h for h in hsms}
        print("\n=== DRY RUN MODE ===")
        for hid in args.hsm_ids:
            hsm = lookup.get(hid)
            if not hsm:
                print(f"[SKIP] {hid} not found in hsm_mapping.json")
                continue
            fw = hsm.get("fwVersion")
            host = hsm.get("ipAddress") or hsm.get("host") or "<no-host>"
            token = version_map.get(fw, "??")
            user, pwd = gen_username(), gen_password()
            print(f"[{hid} | {host}] fw={fw} -> REST v{token}")
            print(f" Would create user={user} pass={pwd} with role={os.path.splitext(args.role_file)[0]}")
        print("=== END DRY RUN ===")
        return

    results = asyncio.run(run_all(args.hsm_ids, args.admin_user, admin_pass, args.role_file, args.insecure, args.test_ssh, args.skip_webserver, args.ssh_user, ssh_pass))
    print("\nRESULTS:")
    for r in results:
        if r["status"] == "OK":
            print(f"[{r['hsm']}] OK user={r['user']} pass={r['password']} ({r['note']})")
        elif r["status"] == "WARN":
            print(f"[{r['hsm']}] WARN user={r['user']} pass={r['password']} not verified")
        else:
            print(f"[{r['hsm']}] FAILED: {r.get('error','see console and resources/failed_jobs.jsonl')}")

if __name__ == "__main__":
    main()
