#!/usr/bin/env python3
"""
user_mgmt.py

Hardened script to create a user+role on Luna HSMs.

Key behavior:
 - Uses SSH credentials you provide (--ssh-user / --ssh-pass or prompted). Does NOT read SSH username from hsm_mapping.json.
 - Uses REST admin credentials you provide (--admin-user and prompted admin password).
 - Bootstraps missing Python packages (asyncssh, portalocker, requests).
 - Uses asyncssh for LunaSH interactions and requests for REST API calls.
"""
from __future__ import annotations
import sys
import subprocess
import importlib
import os
import json
import asyncio
import secrets
import string
import random
import getpass
import base64
import time
import shlex
from typing import Optional, Tuple

# ----------------------------
# Ensure runtime Python packages
# ----------------------------
REQUIRED = ("asyncssh", "portalocker", "requests")
for pkg in REQUIRED:
    try:
        importlib.import_module(pkg)
    except Exception:
        print(f"[INFO] Installing missing package: {pkg}")
        subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])

import asyncssh
import portalocker
import requests

# ----------------------------
# Config
# ----------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
VERSION_FILE = os.path.join(RES_DIR, "version_map.json")
ROLES_DIR = os.path.join(RES_DIR, "roles")
FAILED_LOG = os.path.join(RES_DIR, "failed_jobs.jsonl")
DEFAULT_ROLE_FILE = "user_mgmt_role.txt"

SSH_RETRIES = 3
BACKOFF_BASE = 0.5
BACKOFF_FACTOR = 2.0
BACKOFF_JITTER = 0.2
DEFAULT_REST_PORT = 8443

# ----------------------------
# Helpers
# ----------------------------
def load_json(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def check_fw_version(v: Optional[str], cmp_to: str = "7.8.0") -> bool:
    if not v:
        return False
    def parse(s: str):
        s = s.split("-")[0]
        return tuple(int(x) for x in s.split("."))
    try:
        return parse(v) >= parse(cmp_to)
    except Exception:
        return False

def gen_username() -> str:
    return "usermgmt_" + secrets.token_hex(3)

def gen_password(length: int = 16) -> str:
    chars = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    while True:
        p = ''.join(secrets.choice(chars) for _ in range(length))
        if (any(c.islower() for c in p) and any(c.isupper() for c in p)
                and any(c.isdigit() for c in p) and any(c in "!@#$%^&*()-_=+" for c in p)):
            return p

async def backoff_sleep(attempt: int) -> None:
    base = BACKOFF_BASE * (BACKOFF_FACTOR ** (attempt - 1))
    jitter = random.uniform(-BACKOFF_JITTER, BACKOFF_JITTER)
    await asyncio.sleep(max(0, base + jitter))

def write_failed(entry: dict) -> None:
    os.makedirs(os.path.dirname(FAILED_LOG), exist_ok=True)
    with portalocker.Lock(FAILED_LOG, mode="a", timeout=5) as fh:
        fh.write(json.dumps(entry) + "\n")

def get_content_type_token(version_map: dict, fw_version: Optional[str]) -> str:
    token = version_map.get(fw_version)
    if token is None:
        raise KeyError(f"Firmware version '{fw_version}' not found in {VERSION_FILE}")
    return token

# ----------------------------
# SSH connect helper (password-first like PuTTY)
# ----------------------------
async def connect_password_flexible(host: str, port: int, username: str, password: str, timeout: int = 20, allow_kbd_interactive_fallback: bool = True):
    """
    Try password-only auth first (no agent, no keys, known_hosts=None).
    If AuthenticationFailed, optionally try one kbd-interactive attempt.
    """
    last_exc = None
    # direct password attempt (PuTTY-like)
    args_pw = {
        "username": username,
        "password": password,
        "known_hosts": None,
        "client_keys": None,
        "allow_agent": False,
        "look_for_keys": False,
    }
    try:
        conn = await asyncio.wait_for(asyncssh.connect(host, port=port, **args_pw), timeout=timeout)
        return conn
    except asyncssh.AuthenticationFailed as ae:
        last_exc = ae
        print(f"[SSH:{host}] AuthenticationFailed (password-only).")
    except Exception as e:
        last_exc = e
        print(f"[SSH:{host}] Connection (password-only) failed: {e!r}")

    if allow_kbd_interactive_fallback:
        args_kbd = {
            "username": username,
            "password": password,
            "known_hosts": None,
            "client_keys": None,
            "allow_agent": False,
            "look_for_keys": False,
            "kbd_interactive_auth": True,
        }
        try:
            conn = await asyncio.wait_for(asyncssh.connect(host, port=port, **args_kbd), timeout=timeout)
            print(f"[SSH:{host}] Connected using keyboard-interactive fallback.")
            return conn
        except asyncssh.AuthenticationFailed as ae:
            last_exc = ae
            print(f"[SSH:{host}] Keyboard-interactive auth also failed.")
        except Exception as e:
            last_exc = e
            print(f"[SSH:{host}] Connection (kbd-interactive) failed: {e!r}")

    # other looser attempts
    candidate_list = [
        {"username": username, "password": password, "known_hosts": None, "client_keys": None},
        {"username": username, "password": password, "known_hosts": None},
        {"username": username, "password": password},
    ]
    for args in candidate_list:
        try:
            conn = await asyncio.wait_for(asyncssh.connect(host, port=port, **args), timeout=timeout)
            print(f"[SSH:{host}] Connected using alternative args: {list(args.keys())}")
            return conn
        except Exception as e:
            last_exc = e
            continue

    raise last_exc

# ----------------------------
# PTY runner (robust byte->str)
# ----------------------------
async def run_with_pty(conn, cmd: str, input_text: Optional[str] = None, prompt: str = "lunash>", timeout: int = 20) -> Tuple[str, str, Optional[int]]:
    proc = await conn.create_process(term_type="xterm")
    try:
        if input_text is not None:
            in_bytes = input_text.encode() if isinstance(input_text, str) else input_text
            try:
                proc.stdin.write(in_bytes)
                await proc.stdin.drain()
            except Exception:
                pass
        try:
            proc.stdin.write((cmd + "\n").encode())
            await proc.stdin.drain()
        except Exception:
            pass

        out = ""
        start = time.time()
        while True:
            try:
                chunk = await asyncio.wait_for(proc.stdout.read(1024), timeout=2)
            except asyncio.TimeoutError:
                chunk = b""
            if chunk:
                part = chunk.decode(errors="ignore") if isinstance(chunk, bytes) else str(chunk)
                out += part
                if prompt and prompt.lower() in out.lower():
                    break
            if (time.time() - start) > timeout:
                break

        err = ""
        try:
            while True:
                chunk = await asyncio.wait_for(proc.stderr.read(1024), timeout=0.1)
                if not chunk:
                    break
                err += (chunk.decode(errors="ignore") if isinstance(chunk, bytes) else str(chunk))
        except asyncio.TimeoutError:
            pass

        rc = getattr(proc, "exit_status", None)
        return out, err, rc
    finally:
        try:
            proc.close()
        except Exception:
            pass

# ----------------------------
# LunaSH functions (use only user-supplied SSH creds)
# ----------------------------
async def lunash_check_webserver(hsm: dict, ssh_user: str, ssh_pass: str) -> bool:
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    try:
        conn = await connect_password_flexible(host, port, ssh_user, ssh_pass, timeout=20, allow_kbd_interactive_fallback=False)
        async with conn:
            out, err, _ = await run_with_pty(conn, "webserver show", timeout=10)
            combined = (out or "") + (err or "")
            return "running" in combined.lower()
    except Exception as e:
        print(f"[{hsm.get('id')}] lunash_check_webserver error: {e!r}")
        return False

async def lunash_setup(hsm: dict, ssh_user: str, ssh_pass: str, role_file: str, user: str, pwd: str) -> bool:
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    local_role = os.path.join(ROLES_DIR, role_file)
    if not os.path.exists(local_role):
        raise FileNotFoundError(f"Local role file not found: {local_role}")
    role_name = os.path.splitext(os.path.basename(local_role))[0]
    remote_role = f"/tmp/{os.path.basename(local_role)}"

    print(f"[DEBUG] lunash_setup: hsm_id={hsm.get('id')}, host={host}, port={port}, ssh_user={ssh_user}")
    conn = await connect_password_flexible(host, port, ssh_user, ssh_pass, timeout=25, allow_kbd_interactive_fallback=True)
    try:
        async with conn:
            uploaded = False
            try:
                async with conn.start_sftp_client() as sftp:
                    await sftp.put(local_role, remote_role)
                    uploaded = True
            except Exception:
                uploaded = False

            if not uploaded:
                try:
                    data = base64.b64encode(open(local_role, "rb").read()).decode()
                    remote_b64 = f"/tmp/{os.path.basename(local_role)}.b64"
                    await conn.run(f"rm -f {shlex.quote(remote_b64)}", check=False)
                    chunk_size = 1400
                    for i in range(0, len(data), chunk_size):
                        chunk = data[i:i+chunk_size]
                        cmd = f"printf '%s' {shlex.quote(chunk)} >> {shlex.quote(remote_b64)}"
                        await conn.run(cmd, check=False)
                    await conn.run(f"base64 -d {shlex.quote(remote_b64)} > {shlex.quote(remote_role)}", check=False)
                    await conn.run(f"rm -f {shlex.quote(remote_b64)}", check=False)
                    uploaded = True
                except Exception as e:
                    print(f"[{hsm.get('id')}] role upload fallback failed: {e}")
                    uploaded = False

            if not uploaded:
                raise RuntimeError("Role upload failed")

            cmds = [
                f"user role import {role_name} {remote_role}",
                f"user add -userName {user} -password {pwd}",
                f"user role add {user} {role_name}",
            ]
            for c in cmds:
                out, err, rc = await run_with_pty(conn, c, timeout=25)
                combined = (out or "") + (err or "")
                lower = combined.lower()
                if "permission denied" in lower or "not authorized" in lower:
                    raise RuntimeError(f"LunaSH permission problem: {combined.strip()}")
                if "syntax error" in lower or "not recognized" in lower:
                    raise RuntimeError(f"LunaSH syntax problem: {combined.strip()}")

            pw_input = f"{pwd}\n{pwd}\n"
            out, err, rc = await run_with_pty(conn, f"user password -userName {user}", input_text=pw_input, timeout=20)
            combined = (out or "") + (err or "")
            if "permission denied" in combined.lower():
                raise RuntimeError(f"Setting password failed: {combined.strip()}")

            out, err, rc = await run_with_pty(conn, "user list", timeout=15)
            users_out = (out or "") + (err or "")
            return user in users_out
    finally:
        try:
            conn.close()
        except Exception:
            pass

async def test_ssh_one(hsm: dict, ssh_user: str, ssh_pass: str) -> Tuple[bool, Optional[str]]:
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    try:
        conn = await connect_password_flexible(host, port, ssh_user, ssh_pass, timeout=20, allow_kbd_interactive_fallback=False)
        async with conn:
            out, err, _ = await run_with_pty(conn, "user list", timeout=10)
            snippet = ((out or "") + (err or ""))[:400]
            print(f"[{hsm.get('id')} | {host}] snippet:\n{snippet}")
            return True, None
    except Exception as e:
        return False, str(e)

# ----------------------------
# REST helpers using requests
# ----------------------------
def build_rest_session(base_url: str, admin_user: str, admin_pass: str, ct: str, insecure: bool):
    sess = requests.Session()
    sess.verify = not insecure
    sess.headers.update({"Content-Type": ct})
    url = base_url.rstrip("/") + "/auth/session"
    r = sess.post(url, auth=(admin_user, admin_pass), timeout=20)
    if r.status_code < 200 or r.status_code >= 300:
        raise RuntimeError(f"REST login failed (HTTP {r.status_code}): {r.text[:400]}")
    sid = None
    if "SESSION_ID" in r.cookies:
        sid = r.cookies.get("SESSION_ID")
    else:
        sc = r.headers.get("Set-Cookie", "")
        if "SESSION_ID=" in sc:
            try:
                sid = sc.split("SESSION_ID=")[1].split(";")[0].strip()
            except Exception:
                sid = None
    if not sid:
        raise RuntimeError(f"REST login did not return SESSION_ID cookie. Headers: {r.headers}")
    sess.cookies.set("SESSION_ID", sid)
    return sess, sid

def rest_create_role(sess: requests.Session, base_url: str, role: str, insecure: bool) -> int:
    url = base_url.rstrip("/") + "/roles"
    payload = {"roleId": role}
    r = sess.post(url, json=payload, timeout=20)
    return r.status_code

def rest_put_rolefile(sess: requests.Session, base_url: str, role: str, role_file_path: str, ct_file: str, insecure: bool) -> int:
    url = base_url.rstrip("/") + f"/roles/{role}/resources"
    with open(role_file_path, "rb") as fh:
        headers = {"Content-Type": ct_file}
        r = sess.put(url, data=fh.read(), headers=headers, timeout=30)
    return r.status_code

def rest_create_user(sess: requests.Session, base_url: str, user: str, pwd: str, role: str, insecure: bool) -> int:
    url = base_url.rstrip("/") + "/users"
    payload = {"userId": user, "role": role, "password": pwd}
    r = sess.post(url, json=payload, timeout=20)
    return r.status_code

def rest_get_users(sess: requests.Session, base_url: str, insecure: bool) -> Tuple[int, str]:
    url = base_url.rstrip("/") + "/users"
    r = sess.get(url, timeout=20)
    return r.status_code, r.text

# ----------------------------
# Orchestration per HSM
# ----------------------------
async def process_hsm(hsm: dict, admin_user: str, admin_pass: str, role_file: str,
                      version_map: dict, insecure: bool,
                      test_ssh_only: bool = False, skip_webserver: bool = False,
                      ssh_user: Optional[str] = None, ssh_pass: Optional[str] = None) -> dict:
    """
    IMPORTANT: ssh_user/ssh_pass are taken from CLI or prompts only.
    hsm JSON username fields (if any) are ignored.
    """
    hid = hsm.get("id")
    fw = hsm.get("fwVersion")
    host = hsm.get("ipAddress") or hsm.get("host") or "<no-host>"

    try:
        token = get_content_type_token(version_map, fw)
    except KeyError as e:
        print(f"[{hid}] Version map error: {e}")
        write_failed({"hsm_id": hid, "stage": "version-map", "error": str(e)})
        return {"hsm": hid, "status": "FAILED"}

    ct_json = f"application/vnd.safenetinc.lunasa+json;version={token}"
    ct_file = f"application/vnd.safenetinc.lunasa+file;version={token}"
    print(f"[{hid} | {host}] fw={fw} -> REST v{token}")

    # Ensure we have ssh credentials explicitly supplied
    if not ssh_user:
        # Double-check: we MUST not use anything from the hsm JSON
        raise RuntimeError("SSH username not provided (must pass --ssh-user or set via prompt).")
    if not ssh_pass:
        raise RuntimeError("SSH password not provided (must pass --ssh-pass or set via prompt).")

    # test ssh only mode
    if test_ssh_only:
        ok = False
        last_err = None
        for attempt in range(1, SSH_RETRIES + 1):
            ok, last_err = await test_ssh_one(hsm, ssh_user, ssh_pass)
            if ok:
                break
            print(f"[{hid}] SSH test attempt {attempt} failed: {last_err}")
            if attempt < SSH_RETRIES:
                await backoff_sleep(attempt)
        if not ok:
            write_failed({"hsm_id": hid, "stage": "ssh-test", "error": last_err})
            return {"hsm": hid, "status": "SSH-FAILED", "error": last_err}
        return {"hsm": hid, "status": "SSH-OK"}

    # normal flow: will create username/password and perform REST
    user, pwd = gen_username(), gen_password()
    base = hsm.get("rest_url") or f"https://{host}:{DEFAULT_REST_PORT}"

    # webserver check via LunaSH (uses ssh creds you provided)
    if not skip_webserver:
        ok = False
        last_err = None
        for attempt in range(1, SSH_RETRIES + 1):
            try:
                if await lunash_check_webserver(hsm, ssh_user, ssh_pass):
                    ok = True
                    break
            except Exception as e:
                last_err = str(e)
            print(f"[{hid}] Webserver check attempt {attempt} failed: {last_err if last_err else 'error'}")
            if attempt < SSH_RETRIES:
                await backoff_sleep(attempt)
        if not ok:
            print(f"[{hid}] Webserver check failed (via LunaSH)")
            write_failed({"hsm_id": hid, "stage": "webserver", "error": "Webserver not running (LunaSH)"})
            return {"hsm": hid, "status": "FAILED"}

    # If old firmware: use LunaSH to create role/user (pre-REST sync)
    if not check_fw_version(fw):
        ok = False
        last_err = None
        for attempt in range(1, SSH_RETRIES + 1):
            try:
                res = await lunash_setup(hsm, ssh_user, ssh_pass, role_file, user, pwd)
                if res:
                    ok = True
                    break
            except Exception as e:
                last_err = str(e)
                print(f"[{hid}] LunaSH setup attempt {attempt} failed: {last_err}")
            if attempt < SSH_RETRIES:
                await backoff_sleep(attempt)
        if not ok:
            write_failed({"hsm_id": hid, "stage": "lunash", "error": last_err})
            return {"hsm": hid, "status": "FAILED"}

    # REST flow (create role, upload role file, create user)
    try:
        sess, sid = build_rest_session(base, admin_user, admin_pass, ct_json, insecure)
        role_name = os.path.splitext(role_file)[0]
        rc = rest_create_role(sess, base, role_name, insecure)
        if rc not in (200,201,204,409):
            raise RuntimeError(f"Role create failed (HTTP {rc})")
        role_file_path = os.path.join(ROLES_DIR, role_file)
        if not os.path.exists(role_file_path):
            raise FileNotFoundError(f"Role file not found locally: {role_file_path}")
        rc = rest_put_rolefile(sess, base, role_name, role_file_path, ct_file, insecure)
        if rc not in (200,201,204):
            raise RuntimeError(f"Role upload failed (HTTP {rc})")
        rc = rest_create_user(sess, base, user, pwd, role_name, insecure)
        if rc not in (200,201,204):
            raise RuntimeError(f"User create failed (HTTP {rc})")
        rc_get, out = rest_get_users(sess, base, insecure)
        if user not in out:
            return {"hsm": hid, "status": "WARN", "user": user, "password": pwd}
    except Exception as e:
        print(f"[{hid}] REST error: {e}")
        write_failed({"hsm_id": hid, "stage": "rest", "error": str(e)})
        return {"hsm": hid, "status": "FAILED"}

    return {"hsm": hid, "status": "OK", "user": user, "password": pwd, "note": "password will be forced to change at first login"}

# ----------------------------
# Runner
# ----------------------------
async def run_all(hsm_ids: list[str], admin_user: str, admin_pass: str, role_file: str,
                  insecure: bool, test_ssh_only: bool = False, skip_webserver: bool = False,
                  ssh_user: Optional[str] = None, ssh_pass: Optional[str] = None):
    hsms = load_json(HSM_FILE).get("hsms", [])
    version_map = load_json(VERSION_FILE)
    lookup = {h["id"]: h for h in hsms}
    tasks = []
    for hid in hsm_ids:
        if hid not in lookup:
            print(f"[SKIP] {hid} not found in {HSM_FILE}")
            continue
        tasks.append(process_hsm(lookup[hid], admin_user, admin_pass, role_file, version_map, insecure, test_ssh_only, skip_webserver, ssh_user, ssh_pass))
    return await asyncio.gather(*tasks)

def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--hsm-ids", nargs="+", required=True)
    parser.add_argument("--admin-user", required=True, help="REST admin username")
    parser.add_argument("--role-file", default=DEFAULT_ROLE_FILE)
    parser.add_argument("--insecure", action="store_true")
    parser.add_argument("--dry-run", action="store_true", help="Show what would happen, but do nothing")
    parser.add_argument("--test-ssh", action="store_true", help="Only test SSH auth/connectivity and exit")
    parser.add_argument("--skip-webserver", action="store_true", help="Skip webserver check (LunaSH) and proceed")
    parser.add_argument("--ssh-user", help="SSH username (if not provided you will be prompted)")
    parser.add_argument("--ssh-pass", help="SSH password (optional; if not provided you will be prompted)")
    args = parser.parse_args()

    # Prompt for admin REST password
    admin_pass = getpass.getpass("Admin (REST) password: ")

    # SSH username: prefer flag, else prompt
    ssh_user = args.ssh_user or input("SSH username: ").strip()
    # SSH pass: prefer flag, else prompt
    ssh_pass = args.ssh_pass or getpass.getpass("SSH password: ")

    if args.dry_run:
        hsms = load_json(HSM_FILE).get("hsms", [])
        version_map = load_json(VERSION_FILE)
        lookup = {h["id"]: h for h in hsms}
        print("\n=== DRY RUN MODE ===")
        for hid in args.hsm_ids:
            hsm = lookup.get(hid)
            if not hsm:
                print(f"[SKIP] {hid} not found in hsm_mapping.json")
                continue
            fw = hsm.get("fwVersion")
            host = hsm.get("ipAddress") or hsm.get("host") or "<no-host>"
            token = version_map.get(fw, "??")
            user, pwd = gen_username(), gen_password()
            print(f"[{hid} | {host}] fw={fw} -> REST v{token}")
            print(f" Would create user={user} pass={pwd} with role={os.path.splitext(args.role_file)[0]}")
        print("=== END DRY RUN ===")
        return

    results = asyncio.run(run_all(args.hsm_ids, args.admin_user, admin_pass, args.role_file, args.insecure, args.test_ssh, args.skip_webserver, ssh_user, ssh_pass))
    print("\nRESULTS:")
    for r in results:
        if r["status"] == "OK":
            print(f"[{r['hsm']}] OK user={r['user']} pass={r['password']} ({r['note']})")
        elif r["status"] == "WARN":
            print(f"[{r['hsm']}] WARN user={r['user']} pass={r['password']} not verified")
        else:
            print(f"[{r['hsm']}] FAILED: {r.get('error','see console and resources/failed_jobs.jsonl')}")

if __name__ == "__main__":
    main()
