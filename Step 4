#!/usr/bin/env python3
"""
Minimal Luna HSM SSH login via HSM ID + Webserver check.

- Reads host/port from resources/hsm_mapping.json using --hsm-id
- Prompts once for admin username + password
- Connects via SSH
- Runs `webserver show` to check if webserver is enabled/disabled
- INTERACTIVE: prompts admin whether to create a new LunaSH user; if yes, prompts for
  username and role, generates a temp password, creates the user, assigns the role,
  and saves the temp password (overwritten each run) to resources/user_passwords.json
- Then verifies HSM connectivity by running `hsm show` silently and prints only success message
"""

import argparse
import os
import json
import datetime
import secrets
import string
import platform
import shutil
import subprocess
import getpass
import socket
from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException

# ----------------------------------------------------------------------
# Paths and constants
# ----------------------------------------------------------------------
RES_DIR = "resources"
ROLES_DIR = os.path.join(RES_DIR, "roles")
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
PW_STORE = os.path.join(RES_DIR, "user_passwords.json")
ROLE_LOCAL_PATH = os.path.join(ROLES_DIR, "user_mgmt_role.txt")
REMOTE_ROLE_FILENAME = "user_mgmt_role.txt"
DEFAULT_ROLE_NAME = "user_mgmt_role"

os.makedirs(ROLES_DIR, exist_ok=True)
os.makedirs(RES_DIR, exist_ok=True)

# ----------------------------------------------------------------------
# Concrete role content (only two permissions as requested)
# This role grants minimal user management capabilities:
#   - user.create
#   - user.delete
# ----------------------------------------------------------------------
ROLE_CONTENT = """# user_mgmt_role - minimal permissions
# This role grants a minimal set of user management capabilities.

role_name: user_mgmt_role
description: Minimal user management role created by automation

permissions:
  - user.create    # create new LunaSH users
  - user.delete    # delete LunaSH users
"""

# ----------------------------------------------------------------------
# Utility functions
# ----------------------------------------------------------------------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in mapping.")

def ssh_run(client: SSHClient, cmd: str, timeout: float = 10, input_text: str = None):
    """Run a command on the remote LunaSH shell and return (stdout, stderr, rc)."""
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    if input_text:
        try:
            stdin.write(input_text)
            stdin.flush()
        except Exception:
            pass
    out = stdout.read().decode(errors="ignore")
    err = stderr.read().decode(errors="ignore")
    try:
        rc = stdout.channel.recv_exit_status()
    except Exception:
        rc = -1
    return out, err, rc

def check_webserver_status(client: SSHClient) -> str:
    """Check if the webserver is enabled, disabled, or unsupported."""
    out, err, rc = ssh_run(client, "webserver show")
    combined = (out + err).lower()
    if "running" in combined or "enabled" in combined:
        return "ENABLED"
    if "not running" in combined or "stopped" in combined or "disabled" in combined:
        return "DISABLED"
    if "permission denied" in combined:
        return "NO_PERMISSION"
    if "not recognized" in combined or "unknown command" in combined:
        return "NOT_SUPPORTED"
    return "UNKNOWN"

def _generate_temp_password(length: int = 16) -> str:
    alphabet = string.ascii_letters + string.digits + "._-"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def _save_password_for_user(username: str, password: str):
    """Save generated password for user in a local JSON store with restricted permissions."""
    data = {}
    if os.path.exists(PW_STORE):
        try:
            with open(PW_STORE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            data = {}
    data[username] = {"password": password, "created_at": datetime.datetime.utcnow().isoformat() + "Z"}
    tmp = PW_STORE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, PW_STORE)
    try:
        os.chmod(PW_STORE, 0o600)
    except Exception:
        pass

# ----------------------------------------------------------------------
# Write local role file
# ----------------------------------------------------------------------
def write_local_role_file(path: str, content: str) -> bool:
    """Write the role definition text to a local file for upload."""
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        try:
            os.chmod(path, 0o600)
        except Exception:
            pass
        print(f"[INFO] Local role file written: {path}")
        return True
    except Exception as e:
        print(f"[ERROR] Could not write role file: {e}")
        return False

# ----------------------------------------------------------------------
# Interactive SCP uploader
# ----------------------------------------------------------------------
def scp_upload_role_file(host: str, destination_user: str, password: str, local_path: str) -> bool:
    """
    Upload the role file using scp -O interactively.
    This spawns scp so you will be prompted for the admin password (rotating password).
    """
    if not os.path.exists(local_path):
        print(f"[ERROR] Role file not found: {local_path}")
        return False

    remote = f"{destination_user}@{host}:{REMOTE_ROLE_FILENAME}"
    scp_path = shutil.which("scp")
    # Prefer plain scp -O to match interactive terminal behaviour
    if not scp_path:
        print("[ERROR] scp not found in PATH. Ensure OpenSSH client is installed and scp is reachable.")
        return False

    # Use shell=True so scp prompts for password and you can type it interactively
    cmd = f'scp -O "{local_path}" {remote}'
    print(f"[INFO] Running interactive SCP command:\n  {cmd}")
    try:
        result = subprocess.run(cmd, shell=True)
        if result.returncode == 0:
            print("[INFO] Role file uploaded successfully.")
            return True
        else:
            print(f"[ERROR] SCP upload failed (rc={result.returncode}).")
            return False
    except Exception as e:
        print(f"[ERROR] SCP upload error: {e}")
        return False

# ----------------------------------------------------------------------
# Verify, import and assign functions
# ----------------------------------------------------------------------
def verify_file_on_hsm(client: SSHClient, filename: str) -> bool:
    """Verify uploaded file appears in 'my file list'."""
    out, err, rc = ssh_run(client, "my file list", timeout=15)
    combined = (out + err)
    if rc == 0 and filename in combined:
        print(f"[INFO] Verified uploaded file in 'my file list': {filename}")
        return True
    print(f"[WARN] '{filename}' not found in 'my file list'. Output (truncated):")
    print((combined or "<no output>")[:1000])
    return False

def import_role_and_assign(client: SSHClient, username: str, role_filename: str, role_name: str) -> bool:
    """Import role file and assign the role to a user."""
    print(f"[INFO] Importing role file '{role_filename}' ...")
    out, err, rc = ssh_run(client, f"user role import -file {role_filename}", timeout=30)
    combined = (out + err).lower()
    if rc != 0 or "error" in combined:
        print(f"[ERROR] Role import failed. Output (truncated):\n{(combined or '')[:1000]}")
        return False
    print("[INFO] Role import successful. Assigning role...")
    out2, err2, rc2 = ssh_run(client, f"user role add -username {username} -role {role_name}", timeout=20)
    if rc2 == 0:
        print(f"[INFO] Role '{role_name}' assigned to user '{username}'.")
        return True
    else:
        print(f"[ERROR] Failed to assign role '{role_name}' to '{username}'. Output (truncated):\n{(out2+err2)[:1000]}")
        return False

# ----------------------------------------------------------------------
# User creation (creates user and stores password)
# ----------------------------------------------------------------------
def create_lunash_user_and_store_password(client: SSHClient, username: str, role: str) -> bool:
    """Create a LunaSH user and attempt an early role assign (final import/assign done post-upload)."""
    print(f"[INFO] Creating LunaSH user '{username}' with role '{role}' ...")
    temp_pw = _generate_temp_password(16)
    stdin_payload = f"{temp_pw}\n{temp_pw}\n"
    cmd_add = f"user add -username {username}"
    out, err, rc = ssh_run(client, cmd_add, timeout=60, input_text=stdin_payload)
    combined = (out + err).lower()
    if rc != 0:
        print(f"[ERROR] Creating user failed (rc={rc}). Output (truncated): {(combined)[:800]}")
        return False
    print(f"[INFO] User '{username}' created.")
    # attempt early role add (best-effort)
    cmd_role = f"user role add -username {username} -role {role}"
    out2, err2, rc2 = ssh_run(client, cmd_role, timeout=20)
    if rc2 != 0:
        print(f"[WARN] Early role assign returned rc={rc2} (will try import+assign after upload).")
    _save_password_for_user(username, temp_pw)
    print(f"[INFO] Temporary password saved to {PW_STORE}.")
    return True

# ----------------------------------------------------------------------
# Main flow
# ----------------------------------------------------------------------
def main():
    p = argparse.ArgumentParser()
    p.add_argument("--hsm-id", required=True, help="HSM ID in resources/hsm_mapping.json")
    args = p.parse_args()

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))

    admin_user = input("Username: ").strip()
    admin_pwd = getpass.getpass("Password: ")

    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    try:
        print(f"[INFO] Connecting to {host}:{port} ...")
        client.connect(hostname=host, port=port, username=admin_user, password=admin_pwd, allow_agent=False, look_for_keys=False, timeout=20)
    except AuthenticationException:
        print("[ERROR] Authentication failed.")
        return
    except (SSHException, socket.error) as e:
        print(f"[ERROR] SSH connection failed: {e}")
        return

    web_status = check_webserver_status(client)
    print(f"[WEB SERVER STATUS] {web_status}")

    # create the concrete role file locally
    if not write_local_role_file(ROLE_LOCAL_PATH, ROLE_CONTENT):
        print("[ERROR] Could not create role file. Exiting.")
        client.close()
        return

    answer = input("Create new user now? (y/N): ").strip().lower()
    if answer != "y":
        print("[INFO] Skipping user creation and role upload.")
        client.close()
        return

    new_user = input("Enter new username: ").strip()
    role_name = DEFAULT_ROLE_NAME
    print(f"[INFO] Assigning default role '{role_name}' to user '{new_user}'.")

    # create user (early assign attempted but final import/assign done after upload)
    ok = create_lunash_user_and_store_password(client, new_user, role_name)
    if not ok:
        print("[ERROR] User creation failed. Exiting.")
        client.close()
        return

    # upload role file (interactive scp; you will be prompted for rotating admin password here)
    uploaded = scp_upload_role_file(host, admin_user, admin_pwd, ROLE_LOCAL_PATH)
    if not uploaded:
        print("[ERROR] Role file upload failed. Exiting.")
        client.close()
        return

    # verify and import+assign
    present = verify_file_on_hsm(client, REMOTE_ROLE_FILENAME)
    if not present:
        print("[ERROR] Uploaded file not visible in 'my file list'. It may be in OS staging area; an OS-admin may need to move it.")
        client.close()
        return

    ok2 = import_role_and_assign(client, new_user, REMOTE_ROLE_FILENAME, role_name)
    if ok2:
        print(f"[INFO] user management role imported and assigned to {new_user} successfully.")
    else:
        print("[ERROR] Import/assign step failed. Check role file format and LunaSH output.")

    # final hsm show check
    _, _, rc = ssh_run(client, "hsm show", timeout=20)
    if rc == 0:
        print("[INFO] HSM connectivity verified.")
    else:
        print("[WARN] HSM show returned non-zero exit code.")

    client.close()

if __name__ == "__main__":
    main()
