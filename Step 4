#!/usr/bin/env python3
"""
Minimal Luna HSM SSH login via HSM ID + Webserver check.

- Reads host/port from resources/hsm_mapping.json using --hsm-id
- Prompts once for admin username + password
- Connects via SSH
- Runs `webserver show` to check if webserver is enabled/disabled
- INTERACTIVE: prompts admin whether to create a new LunaSH user; if yes, prompts for
  username and role, generates a temp password, creates the user, assigns the role,
  and saves the temp password (overwritten each run) to resources/user_passwords.json
- Then verifies HSM connectivity by running `hsm show` silently and prints only success message
"""

import argparse
import os
import json
import datetime
import secrets
import string
import platform
import shutil
import subprocess
import getpass
import socket
from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException

# ----------------------------------------------------------------------
# Paths and constants
# ----------------------------------------------------------------------
RES_DIR = "resources"
ROLES_DIR = os.path.join(RES_DIR, "roles")
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
PW_STORE = os.path.join(RES_DIR, "user_passwords.json")
ROLE_LOCAL_PATH = os.path.join(ROLES_DIR, "user_mgmt_role.txt")
REMOTE_ROLE_FILENAME = "user_mgmt_role.txt"
DEFAULT_ROLE_NAME = "user_mgmt_role"

os.makedirs(ROLES_DIR, exist_ok=True)
os.makedirs(RES_DIR, exist_ok=True)

# ----------------------------------------------------------------------
# Role content - minimal user management permissions
# ----------------------------------------------------------------------
ROLE_CONTENT = """# user_mgmt_role - minimal permissions
# Grants basic LunaSH user management rights

role_name: user_mgmt_role
description: Minimal user management role created by automation

permissions:
  - user.create
  - user.delete
"""

# ----------------------------------------------------------------------
# Utility functions
# ----------------------------------------------------------------------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in mapping.")

def ssh_run(client: SSHClient, cmd: str, timeout: float = 10, input_text: str = None):
    """Run command on LunaSH and return stdout, stderr, and exit code."""
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    if input_text:
        try:
            stdin.write(input_text)
            stdin.flush()
        except Exception:
            pass
    out = stdout.read().decode(errors="ignore")
    err = stderr.read().decode(errors="ignore")
    try:
        rc = stdout.channel.recv_exit_status()
    except Exception:
        rc = -1
    return out, err, rc

def check_webserver_status(client: SSHClient) -> str:
    """Check if the webserver is running."""
    out, err, rc = ssh_run(client, "webserver show")
    combined = (out + err).lower()
    if "running" in combined or "enabled" in combined:
        return "ENABLED"
    if "not running" in combined or "stopped" in combined or "disabled" in combined:
        return "DISABLED"
    if "permission denied" in combined:
        return "NO_PERMISSION"
    if "not recognized" in combined or "unknown command" in combined:
        return "NOT_SUPPORTED"
    return "UNKNOWN"

def _generate_temp_password(length: int = 16) -> str:
    alphabet = string.ascii_letters + string.digits + "._-"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def _save_password_for_user(username: str, password: str):
    """Save temp password to local JSON store securely."""
    data = {}
    if os.path.exists(PW_STORE):
        try:
            with open(PW_STORE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            data = {}
    data[username] = {"password": password, "created_at": datetime.datetime.utcnow().isoformat() + "Z"}
    tmp = PW_STORE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, PW_STORE)
    try:
        os.chmod(PW_STORE, 0o600)
    except Exception:
        pass

# ----------------------------------------------------------------------
# Create role file locally
# ----------------------------------------------------------------------
def write_local_role_file(path: str, content: str) -> bool:
    """Create the local role file used for import."""
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        try:
            os.chmod(path, 0o600)
        except Exception:
            pass
        print(f"[INFO] Local role file written: {path}")
        return True
    except Exception as e:
        print(f"[ERROR] Could not write role file: {e}")
        return False

# ----------------------------------------------------------------------
# Interactive SCP upload
# ----------------------------------------------------------------------
def scp_upload_role_file(host: str, destination_user: str, password: str, local_path: str) -> bool:
    """
    Upload the role file to the HSM using scp -O.
    Prompts for password interactively each time.
    """
    if not os.path.exists(local_path):
        print(f"[ERROR] Role file not found: {local_path}")
        return False

    remote = f"{destination_user}@{host}:{REMOTE_ROLE_FILENAME}"
    scp_path = shutil.which("scp")

    if not scp_path:
        print("[ERROR] scp not found in PATH. Please install OpenSSH client.")
        return False

    cmd = f'scp -O "{local_path}" {remote}'
    print(f"[INFO] Running interactive SCP command:\n  {cmd}")
    try:
        result = subprocess.run(cmd, shell=True)
        if result.returncode == 0:
            print("[INFO] Role file uploaded successfully.")
            return True
        else:
            print(f"[ERROR] SCP upload failed. Return code: {result.returncode}")
            return False
    except Exception as e:
        print(f"[ERROR] SCP upload error: {e}")
        return False

# ----------------------------------------------------------------------
# Verify and import role (version-aware)
# ----------------------------------------------------------------------
def import_role_and_assign(client: SSHClient, username: str, role_filename: str, role_name: str) -> bool:
    """Import role and assign to user, automatically adapting to Luna version differences."""
    out_ver, _, _ = ssh_run(client, "version", timeout=10)
    version_text = out_ver.strip().lower()
    print(f"[INFO] Detected HSM version:\n{version_text}")

    # select import syntax based on version
    if any(v in version_text for v in ["7.6", "7.7", "7.8"]):
        cmd_import = f"user role import -role {role_name} -file {role_filename}"
    else:
        cmd_import = f"user role import -file {role_filename}"

    print(f"[INFO] Importing role file using syntax:\n  {cmd_import}")
    out, err, rc = ssh_run(client, cmd_import, timeout=40)
    combined = (out + err).lower()

    # fallback for legacy 7.2.x builds
    if rc != 0 or "not found" in combined or "unrecognized" in combined:
        print("[WARN] Import failed or not recognized. Trying legacy fallback syntax ...")
        alt_cmd = f"user role import {role_filename}"
        out, err, rc = ssh_run(client, alt_cmd, timeout=40)
        combined = (out + err).lower()

    if rc != 0 or "error" in combined:
        print(f"[ERROR] Role import failed. Output (truncated):\n{(combined or '')[:1000]}")
        return False

    print("[INFO] Role import successful. Assigning role...")
    out2, err2, rc2 = ssh_run(client, f"user role add -username {username} -role {role_name}", timeout=25)
    if rc2 == 0:
        print(f"[INFO] Role '{role_name}' assigned to user '{username}'.")
        return True
    else:
        print(f"[ERROR] Failed to assign role '{role_name}' to '{username}'. Output (truncated):\n{(out2+err2)[:1000]}")
        return False

# ----------------------------------------------------------------------
# User creation
# ----------------------------------------------------------------------
def create_lunash_user_and_store_password(client: SSHClient, username: str, role: str) -> bool:
    """Create a LunaSH user and store its password."""
    print(f"[INFO] Creating LunaSH user '{username}' with role '{role}' ...")
    temp_pw = _generate_temp_password(16)
    stdin_payload = f"{temp_pw}\n{temp_pw}\n"
    cmd_add = f"user add -username {username}"
    out, err, rc = ssh_run(client, cmd_add, timeout=60, input_text=stdin_payload)
    combined = (out + err).lower()
    if rc != 0:
        print(f"[ERROR] Creating user failed (rc={rc}). Output (truncated): {(combined)[:800]}")
        return False
    print(f"[INFO] User '{username}' created successfully.")
    _save_password_for_user(username, temp_pw)
    print(f"[INFO] Temporary password saved to {PW_STORE}.")
    return True

# ----------------------------------------------------------------------
# Main flow
# ----------------------------------------------------------------------
def main():
    p = argparse.ArgumentParser()
    p.add_argument("--hsm-id", required=True, help="HSM ID from mapping file")
    args = p.parse_args()

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))

    admin_user = input("Username: ").strip()
    admin_pwd = getpass.getpass("Password: ")

    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    try:
        print(f"[INFO] Connecting to {host}:{port} ...")
        client.connect(hostname=host, port=port, username=admin_user, password=admin_pwd, allow_agent=False, look_for_keys=False, timeout=20)
    except AuthenticationException:
        print("[ERROR] Authentication failed.")
        return
    except (SSHException, socket.error) as e:
        print(f"[ERROR] SSH connection failed: {e}")
        return

    web_status = check_webserver_status(client)
    print(f"[WEB SERVER STATUS] {web_status}")

    # create local role file
    if not write_local_role_file(ROLE_LOCAL_PATH, ROLE_CONTENT):
        print("[ERROR] Could not create local role file. Exiting.")
        client.close()
        return

    answer = input("Create new user now? (y/N): ").strip().lower()
    if answer != "y":
        print("[INFO] Skipping user creation and role upload.")
        client.close()
        return

    new_user = input("Enter new username: ").strip()
    role_name = DEFAULT_ROLE_NAME
    print(f"[INFO] Preparing to assign role '{role_name}' to new user '{new_user}'.")

    if not create_lunash_user_and_store_password(client, new_user, role_name):
        print("[ERROR] User creation failed. Exiting.")
        client.close()
        return

    # upload and verify
    if not scp_upload_role_file(host, admin_user, admin_pwd, ROLE_LOCAL_PATH):
        print("[ERROR] Role file upload failed. Exiting.")
        client.close()
        return

    out, _, _ = ssh_run(client, "my file list", timeout=15)
    if REMOTE_ROLE_FILENAME not in out:
        print(f"[ERROR] Uploaded file not visible in 'my file list'. Exiting.")
        client.close()
        return

    # import + assign
    if import_role_and_assign(client, new_user, REMOTE_ROLE_FILENAME, role_name):
        print(f"[INFO] Role successfully imported and assigned to {new_user}.")
    else:
        print("[ERROR] Import/assign step failed. Check LunaSH output above.")

    _, _, rc = ssh_run(client, "hsm show", timeout=20)
    if rc == 0:
        print("[INFO] HSM connectivity verified.")
    else:
        print("[WARN] HSM show returned non-zero exit code.")

    client.close()

if __name__ == "__main__":
    main()
