Luna HSM User Management Automation

Overview

This document describes the automation used for managing service users on Luna Hardware Security Modules (HSMs). The automation is implemented through two Python scripts that perform user and role management in a controlled and repeatable manner.

The scripts handle the following operational tasks:
	•	Creating a service user on the HSM
	•	Creating or validating a role with required permissions
	•	Assigning the role to the user
	•	Generating and storing credentials

Two different technical approaches are supported:
	•	SSH-based automation using LunaSH
	•	REST API–based automation using HTTPS

Both approaches achieve the same functional outcome. The difference lies in how the scripts communicate with the HSM.

⸻

Scripts in Scope

um_lunash.py (SSH-based)

This script connects to the HSM using SSH and executes LunaSH commands. It behaves in a similar way to a human operator manually logging into the HSM and performing administrative tasks via the command line.

It dynamically detects the firmware version running on the HSM, builds role definitions at runtime, and supports resetting passwords for existing users.

⸻

um_rest_api.py (REST-based)

This script connects to the HSM using the Luna REST APIs over HTTPS. Instead of shell commands, all operations are performed using API calls.

It relies on predefined firmware-to-API mappings and static role definitions. It is more conservative in behaviour and does not modify existing users.

⸻

Repository Structure

The repository has the following structure:
.
├── um_lunash.py
├── um_rest_api.py
└── resources/
    ├── hsm_mapping.json
    ├── user_passwords.json
    ├── version_map.json
    └── usermanagement.txt

All external configuration and runtime data is stored under the resources directory. The scripts themselves do not contain any hard-coded environment or system-specific values.

⸻

Configuration and Resources

The resources directory

The resources directory contains all configuration files required by the automation. Both scripts depend on this directory to function correctly.

This design allows the behaviour of the automation to be changed without modifying the code. Any change in HSM inventory, firmware versions, or permissions is handled by updating these files.

⸻

hsm_mapping.json

This file defines all HSM systems that the automation is allowed to interact with. It acts as the central inventory of HSM connection details.

Each entry typically contains:
	•	A unique HSM identifier
	•	IP address
	•	SSH port
	•	Firmware version

When the script is executed, the value passed using --hsm-id is looked up in this file. If the ID is not present, execution stops immediately.

For the SSH script, this file provides network connection details.
For the REST script, the firmware value is also used to determine which REST API version should be used.

This file is the single authoritative source for HSM information.

⸻

user_passwords.json

This file stores all credentials generated by the automation. It is created automatically if it does not already exist.

For each user, the file records:
	•	Username
	•	Generated password
	•	Timestamp of creation (UTC)

Passwords are never printed to the console. This file is the only place where generated credentials can be retrieved after execution.

This file must be treated as sensitive operational data. It should not be committed to version control and should have restricted file permissions.

⸻

version_map.json (REST only)

This file is used only by the REST-based script.

The Luna REST APIs are versioned, and the correct API version depends on the firmware running on the HSM. This file provides the mapping between firmware versions and REST API versions.

During execution:
	1.	The script reads the firmware version from hsm_mapping.json.
	2.	Looks up the firmware in version_map.json.
	3.	Uses the mapped API version to construct all REST endpoints.

If no mapping exists, the script exits immediately. There is no fallback logic.

This file must be updated whenever new firmware versions are introduced.

⸻

usermanagement.txt (REST only)

This file contains the static role definition used by the REST-based script.

It defines all permissions that will be granted to the service user. The REST script uploads this file to the HSM and attaches it to the created role.

Any change to user permissions must be done by editing this file. Unlike the SSH script, the REST script does not generate role definitions dynamically.

⸻

Environments and User Mapping

Both scripts operate using predefined environments:
	•	DEV
	•	TE1
	•	TE2
	•	PROD

Each environment maps to a fixed service user:

DEV → svc_at4894_usrmgt
TE1 → svc_at48993_usrmgt
TE2 → svc_at48992_usrmgt
PROD → svc_at49008_usrmgt

The SSH script allows overriding this mapping using a command-line argument.
The REST script enforces this mapping strictly.

⸻

Password Handling

Passwords are generated automatically using secure random logic. They are never hard-coded, reused, or displayed on the terminal.

All generated credentials are written to user_passwords.json.

The SSH script updates this file every time a password is reset.
The REST script only writes to it when a new user is created.

⸻

SSH Script Behaviour (Detailed)

When the SSH script is executed, it follows this process:
	1.	Parses and validates command-line arguments.
	2.	Resolves the target username.
	3.	Loads HSM connection details from the mapping file.
	4.	Establishes an SSH connection to the HSM.
	5.	Executes version commands to detect firmware.
	6.	Selects the appropriate role definition.
	7.	Generates a role file locally.
	8.	Uploads the role file using SCP.
	9.	Imports the role into the HSM.
	10.	Attempts to create the user.
	11.	If the user already exists, resets the password.
	12.	Assigns the role to the user.
	13.	Deletes temporary role files.
	14.	Prints a summary of execution.

Key characteristics of the SSH script:
	•	Safe to re-run
	•	Always enforces password rotation
	•	Uses fallback role if version detection fails
	•	More flexible and forgiving

⸻

REST Script Behaviour (Detailed)

When the REST script is executed, it follows this process:
	1.	Ensures required Python packages are installed.
	2.	Loads HSM mapping and firmware version.
	3.	Resolves REST API version using version_map.json.
	4.	Authenticates using the REST session endpoint.
	5.	Establishes a session using cookies.
	6.	Checks whether the user already exists.
	7.	If the user exists, exits without changes.
	8.	Creates a role via REST APIs.
	9.	Uploads permissions from usermanagement.txt.
	10.	Generates a password.
	11.	Creates the user and assigns the role.
	12.	Stores credentials locally.
	13.	Prints completion message.

Key characteristics of the REST script:
	•	Never modifies existing users
	•	No fallback behaviour
	•	Highly deterministic
	•	Designed for strict environments

⸻

Behavioural Comparison

Aspect
SSH Script
REST Script
Interface
LunaSH
REST API
Role creation
Dynamic
Static
Firmware handling
Detection
Mapping
Existing user
Reset password
Exit
Re-run behaviour
Idempotent
Non-destructive


Operational Notes
	•	Neither script deletes users or roles.
	•	No rollback functionality exists.
	•	All operations are explicit and manual.
	•	Scripts are intended for controlled internal environments only.
	•	Configuration files must be kept in sync with the real environment.

⸻

Summary

The Luna HSM User Management automation provides a controlled and auditable way to manage service users on HSM devices.

Both scripts implement the same logical workflow: environment resolution, role configuration, user creation, and credential storage. The only difference is the technical interface used to perform these actions.

From an operational perspective, both approaches are equivalent and should be chosen based on available access methods and security policies.
