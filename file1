#!/usr/bin/env python3
"""
user_mgmt.py

Single-credential version:
 - One username/password is used for BOTH SSH (LunaSH) and REST API.
 - No double prompts.
 - Webserver check fixed.
"""

import sys, subprocess, importlib, os, json, asyncio, secrets, string, random, getpass, base64, time, shlex

# ----------------------------
# Bootstrap dependencies
# ----------------------------
REQUIRED = ("asyncssh", "portalocker", "requests")
for pkg in REQUIRED:
    try:
        importlib.import_module(pkg)
    except Exception:
        print(f"[INFO] Installing missing package: {pkg}")
        subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])

import asyncssh, portalocker, requests

# ----------------------------
# Config
# ----------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
VERSION_FILE = os.path.join(RES_DIR, "version_map.json")
ROLES_DIR = os.path.join(RES_DIR, "roles")
FAILED_LOG = os.path.join(RES_DIR, "failed_jobs.jsonl")
DEFAULT_ROLE_FILE = "user_mgmt_role.txt"
DEFAULT_REST_PORT = 8443

SSH_RETRIES = 3
BACKOFF_BASE = 0.5
BACKOFF_FACTOR = 2.0
BACKOFF_JITTER = 0.2

# ----------------------------
# Helpers
# ----------------------------
def load_json(path): return json.load(open(path, "r"))

def check_fw_version(v, cmp_to="7.8.0"):
    if not v: return False
    def parse(s): return tuple(int(x) for x in s.split("-")[0].split("."))
    return parse(v) >= parse(cmp_to)

def gen_username(): return "usermgmt_" + secrets.token_hex(3)

def gen_password(length=16):
    chars = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    while True:
        p = ''.join(secrets.choice(chars) for _ in range(length))
        if (any(c.islower() for c in p) and any(c.isupper() for c in p)
                and any(c.isdigit() for c in p) and any(c in "!@#$%^&*()-_=+" for c in p)):
            return p

async def backoff_sleep(attempt):
    base = BACKOFF_BASE * (BACKOFF_FACTOR ** (attempt-1))
    jitter = random.uniform(-BACKOFF_JITTER, BACKOFF_JITTER)
    await asyncio.sleep(max(0, base+jitter))

def write_failed(entry):
    os.makedirs(os.path.dirname(FAILED_LOG), exist_ok=True)
    with portalocker.Lock(FAILED_LOG, "a", timeout=5) as fh:
        fh.write(json.dumps(entry)+"\n")

def get_content_type_token(version_map, fw_version):
    token = version_map.get(fw_version)
    if not token:
        raise KeyError(f"Firmware {fw_version} not in {VERSION_FILE}")
    return token

# ----------------------------
# SSH helpers
# ----------------------------
async def connect_password(host, port, username, password, timeout=20):
    args = {
        "username": username,
        "password": password,
        "known_hosts": None,
        "client_keys": None,
        "allow_agent": False,
        "look_for_keys": False,
    }
    return await asyncio.wait_for(asyncssh.connect(host, port=port, **args), timeout=timeout)

async def run_with_pty(conn, cmd, prompt="lunash>", timeout=20, input_text=None):
    proc = await conn.create_process(term_type="xterm")
    try:
        if input_text:
            proc.stdin.write(input_text.encode() if isinstance(input_text, str) else input_text)
            await proc.stdin.drain()
        proc.stdin.write((cmd+"\n").encode()); await proc.stdin.drain()
        out, start = "", time.time()
        while True:
            try: chunk = await asyncio.wait_for(proc.stdout.read(1024), timeout=2)
            except asyncio.TimeoutError: chunk=b""
            if chunk: 
                out += chunk.decode(errors="ignore")
                if prompt.lower() in out.lower(): break
            if time.time()-start > timeout: break
        return out, await proc.stderr.read(), getattr(proc,"exit_status",None)
    finally:
        proc.close()

# ----------------------------
# Webserver check
# ----------------------------
async def lunash_check_webserver(hsm, user, pwd):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port",22))
    try:
        conn = await connect_password(host, port, user, pwd)
        async with conn:
            out, err, _ = await run_with_pty(conn, "webserver show")
            return "running" in (out+err).lower()
    except Exception as e:
        print(f"[{hsm.get('id')}] webserver check error: {e}")
        return False

# ----------------------------
# REST helpers (requests)
# ----------------------------
def build_rest_session(base_url, user, pwd, ct, insecure):
    sess = requests.Session(); sess.verify=not insecure; sess.headers.update({"Content-Type": ct})
    r = sess.post(base_url.rstrip("/")+"/auth/session", auth=(user,pwd), timeout=20)
    if r.status_code>=300: raise RuntimeError(f"REST login failed: {r.status_code} {r.text[:200]}")
    sid = r.cookies.get("SESSION_ID") or r.headers.get("Set-Cookie","").split("SESSION_ID=")[-1].split(";")[0].strip()
    if not sid: raise RuntimeError("No SESSION_ID returned")
    sess.cookies.set("SESSION_ID", sid); return sess

def rest_create_role(sess, base_url, role): return sess.post(base_url+"/roles", json={"roleId":role}).status_code
def rest_put_rolefile(sess, base_url, role, path, ct_file): return sess.put(f"{base_url}/roles/{role}/resources", data=open(path,"rb").read(), headers={"Content-Type":ct_file}).status_code
def rest_create_user(sess, base_url, user, pwd, role): return sess.post(base_url+"/users", json={"userId":user,"role":role,"password":pwd}).status_code
def rest_get_users(sess, base_url): r=sess.get(base_url+"/users"); return r.status_code,r.text

# ----------------------------
# Orchestration
# ----------------------------
async def process_hsm(hsm, user, pwd, role_file, version_map, insecure, skip_webserver=False):
    hid, fw = hsm.get("id"), hsm.get("fwVersion")
    host = hsm.get("ipAddress") or hsm.get("host")
    token = get_content_type_token(version_map, fw)
    ct_json=f"application/vnd.safenetinc.lunasa+json;version={token}"
    ct_file=f"application/vnd.safenetinc.lunasa+file;version={token}"
    print(f"[{hid} | {host}] fw={fw} -> REST v{token}")

    if not skip_webserver and not await lunash_check_webserver(hsm,user,pwd):
        return {"hsm":hid,"status":"FAILED","error":"webserver not running"}

    new_user,new_pwd=gen_username(),gen_password()
    base=hsm.get("rest_url") or f"https://{host}:{DEFAULT_REST_PORT}"
    try:
        sess=build_rest_session(base,user,pwd,ct_json,insecure)
        role=os.path.splitext(role_file)[0]
        if rest_create_role(sess,base,role) not in (200,201,204,409): raise RuntimeError("role create fail")
        role_path=os.path.join(ROLES_DIR,role_file)
        if rest_put_rolefile(sess,base,role,role_path,ct_file) not in (200,201,204): raise RuntimeError("role upload fail")
        if rest_create_user(sess,base,new_user,new_pwd,role) not in (200,201,204): raise RuntimeError("user create fail")
        code,body=rest_get_users(sess,base)
        if new_user not in body: return {"hsm":hid,"status":"WARN","user":new_user,"password":new_pwd}
    except Exception as e:
        return {"hsm":hid,"status":"FAILED","error":str(e)}

    return {"hsm":hid,"status":"OK","user":new_user,"password":new_pwd}

# ----------------------------
# Runner
# ----------------------------
async def run_all(hsm_ids,user,pwd,role_file,insecure,skip_webserver):
    hsms=load_json(HSM_FILE).get("hsms",[]); vm=load_json(VERSION_FILE)
    lookup={h["id"]:h for h in hsms}
    return await asyncio.gather(*[process_hsm(lookup[hid],user,pwd,role_file,vm,insecure,skip_webserver) for hid in hsm_ids if hid in lookup])

def main():
    import argparse
    p=argparse.ArgumentParser()
    p.add_argument("--hsm-ids",nargs="+",required=True)
    p.add_argument("--user",required=True,help="Username (used for both SSH and REST)")
    p.add_argument("--role-file",default=DEFAULT_ROLE_FILE)
    p.add_argument("--insecure",action="store_true")
    p.add_argument("--skip-webserver",action="store_true")
    args=p.parse_args()
    pwd=getpass.getpass("Password (used for both SSH and REST): ")
    results=asyncio.run(run_all(args.hsm_ids,args.user,pwd,args.role_file,args.insecure,args.skip_webserver))
    print("\nRESULTS:")
    for r in results: print(r)

if __name__=="__main__": main()
