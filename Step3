#!/usr/bin/env python3
"""
Minimal Luna HSM user management (base64-only uploader, LunaSH-safe).

Usage:
  python luna_user_mgmt_base64_only.py --hsm-id hsma1
  python luna_user_mgmt_base64_only.py --hsm-id hsma1 --role-file user_mgmt_role.txt --new-user alice
"""

from __future__ import annotations
import os, sys, json, time, getpass, argparse, secrets, string, base64, subprocess, re, socket
from typing import Tuple

# install paramiko if needed (we use it only for SSH)
try:
    import paramiko
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "paramiko"])
    import paramiko

from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
RES_DIR = os.path.join(BASE_DIR, "resources")
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
ROLES_DIR = os.path.join(RES_DIR, "roles")

# We upload base64 to /tmp/roledef.txt.b64 then decode to /tmp/roledef.txt
REMOTE_B64 = "/tmp/roledef.txt.b64"
REMOTE_ROLE = "/tmp/roledef.txt"
SSH_TIMEOUT = 20.0

# ---- helpers ----
def parse_version_tuple(s: str) -> Tuple[int, ...]:
    if not s:
        return tuple()
    s = s.split("-")[0].strip()
    parts = []
    for p in s.split("."):
        try:
            parts.append(int(p))
        except Exception:
            parts.append(0)
    return tuple(parts)

def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as fh:
        data = json.load(fh)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in {HSM_FILE}")

def ssh_connect(host: str, port: int, user: str, pwd: str, timeout: float = SSH_TIMEOUT) -> SSHClient:
    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    try:
        client.connect(hostname=host, port=port, username=user, password=pwd,
                       allow_agent=False, look_for_keys=False, timeout=timeout)
        return client
    except AuthenticationException:
        raise SystemExit("[ERROR] Authentication failed (check username/password).")
    except (SSHException, socket.error) as e:
        raise SystemExit(f"[ERROR] SSH connection failed: {e}")

def ssh_run(client: SSHClient, cmd: str, timeout: float = 30.0):
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    out = stdout.read().decode(errors="ignore") if stdout else ""
    err = stderr.read().decode(errors="ignore") if stderr else ""
    try:
        rc = stdout.channel.recv_exit_status()
    except Exception:
        rc = -1
    return out, err, rc

def gen_password(length: int = 16) -> str:
    chars = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    while True:
        p = ''.join(secrets.choice(chars) for _ in range(length))
        if (any(c.islower() for c in p) and any(c.isupper() for c in p)
                and any(c.isdigit() for c in p) and any(c in "!@#$%^&*()-_=+" for c in p)):
            return p

def sh_escape(s: str) -> str:
    # single-quote safe escaping for echo
    return "'" + s.replace("'", "'\"'\"'") + "'"

# ---- base64 upload to /tmp ----
def upload_via_base64_to_tmp(client: SSHClient, local_path: str) -> None:
    """
    Uploads local_path to REMOTE_B64 in chunks and decodes to REMOTE_ROLE.
    Uses only echo/append and base64 -d which LunaSH supports on most devices.
    """
    if not os.path.exists(local_path):
        raise SystemExit(f"[ERROR] Role file not found: {local_path}")

    # normalize file (strip BOM, force LF) to avoid parser issues
    data = open(local_path, "rb").read()
    if data.startswith(b'\xef\xbb\xbf'):
        data = data[3:]
    data = data.replace(b'\r\n', b'\n').replace(b'\r', b'\n')

    b64 = base64.b64encode(data).decode()

    # remove any existing remote files (best-effort)
    ssh_run(client, f"rm -f {REMOTE_B64} {REMOTE_ROLE}")

    chunk_size = 1200
    for i in range(0, len(b64), chunk_size):
        chunk = b64[i:i+chunk_size]
        # append chunk to remote base64 file using echo >> (safer for Luna)
        # Use single-quote escaping
        cmd = f"echo {sh_escape(chunk)} >> {REMOTE_B64}"
        out, err, rc = ssh_run(client, cmd, timeout=10.0)
        # we ignore rc here because some firmwares return nonzero for echo; but capture errors
        if rc not in (0, None):
            # print debug but continue â€” many Luna boxes return non-zero for some shell ops
            print(f"[DEBUG] echo rc={rc} (ignored) out({out.strip()}) err({err.strip()})")

    # decode base64 to final role file
    out, err, rc = ssh_run(client, f"base64 -d {REMOTE_B64} > {REMOTE_ROLE}", timeout=20.0)
    if rc != 0:
        raise SystemExit(f"[ERROR] base64 decode failed: {out or err}")
    # cleanup b64
    ssh_run(client, f"rm -f {REMOTE_B64}")

    print(f"[INFO] Uploaded role file to {REMOTE_ROLE} via base64.")

# ---- firmware-aware role import (includes positional with /tmp path) ----
def import_role_firmware_aware(client: SSHClient, hsm: dict, role_name: str) -> None:
    fw = hsm.get("fwVersion") or ""
    fw_tuple = parse_version_tuple(fw)

    # candidate syntaxes; the first that succeeds wins
    # include both flagged variants and positional with /tmp path
    if fw_tuple >= parse_version_tuple("7.8.0"):
        candidates = [
            f"user role import -roleName {role_name} -file {REMOTE_ROLE}",
            f"user role import -role {role_name} -file {REMOTE_ROLE}",
            f"user role import {role_name} {REMOTE_ROLE}",
        ]
    elif fw_tuple >= parse_version_tuple("7.3.0"):
        candidates = [
            f"user role import -role {role_name} -file {REMOTE_ROLE}",
            f"user role import {role_name} {REMOTE_ROLE}",
            f"user role import -roleName {role_name} -file {REMOTE_ROLE}",
        ]
    else:
        candidates = [
            f"user role import {role_name} {REMOTE_ROLE}",
            f"user role import -role {role_name} -file {REMOTE_ROLE}",
            f"user role import -roleName {role_name} -file {REMOTE_ROLE}",
        ]

    last_err = None
    for cmd in candidates:
        print(f"[INFO] Trying import command: {cmd}")
        out, err, rc = ssh_run(client, cmd, timeout=20.0)
        raw = (out or "") + (err or "")
        print(f"[DEBUG] rc={rc} raw: {raw.strip()[:400]}")
        lower = raw.lower()
        # success heuristic: rc==0 and no 'error' or 'syntax' tokens in reply
        if rc == 0 and "error" not in lower and "syntax" not in lower:
            print(f"[INFO] Role '{role_name}' imported successfully using: {cmd}")
            return
        last_err = raw.strip()
        print(f"[WARN] Attempt failed (rc={rc}): {last_err}")

    raise SystemExit(f"[ERROR] Role import failed after trying syntaxes. Last error: {last_err}")

# ---- user management helpers ----
def add_user(client: SSHClient, username: str, password: str) -> None:
    out, err, rc = ssh_run(client, f"user add -userName {username} -password {password}", timeout=20.0)
    if rc != 0:
        raise SystemExit(f"[ERROR] Add user failed: {out or err}")
    print(f"[INFO] User '{username}' created.")

def assign_role(client: SSHClient, username: str, role_name: str) -> None:
    out, err, rc = ssh_run(client, f"user role add {username} {role_name}", timeout=15.0)
    if rc != 0:
        raise SystemExit(f"[ERROR] Assign role failed: {out or err}")
    print(f"[INFO] Role '{role_name}' assigned to '{username}'.")

def set_password_interactive(client: SSHClient, username: str, pwd: str, timeout: float = 6.0) -> None:
    chan = client.invoke_shell()
    time.sleep(0.2)
    chan.send(f"user password -userName {username}\n")
    time.sleep(0.2)
    chan.send(pwd + "\n")
    time.sleep(0.2)
    chan.send(pwd + "\n")
    buff = ""
    start = time.time()
    while time.time() - start < timeout:
        if chan.recv_ready():
            buff += chan.recv(4096).decode(errors="ignore")
        else:
            time.sleep(0.05)
    chan.close()
    if "permission denied" in buff.lower() or "not authorized" in buff.lower():
        raise SystemExit(f"[ERROR] Setting password failed: {buff.strip()}")
    print(f"[INFO] Password set for '{username}' (may require change at first login).")

# ---- main flow ----
def main():
    p = argparse.ArgumentParser()
    p.add_argument("--hsm-id", required=True)
    p.add_argument("--cmd", help="Optional LunaSH command to run")
    p.add_argument("--role-file", help="Role filename in resources/roles/")
    p.add_argument("--new-user", help="New username to create")
    args = p.parse_args()

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))

    user = input("Username: ").strip()
    pwd = getpass.getpass("Password: ")

    print(f"[INFO] Connecting to {host}:{port} as {user} ...")
    client = ssh_connect(host, port, user, pwd)

    # simple webserver check (LunaSH command)
    out, err, rc = ssh_run(client, "webserver show", timeout=10.0)
    combined = (out + err).lower()
    if "running" in combined or "enabled" in combined:
        print("[WEB SERVER STATUS] ENABLED")
    else:
        print("[WEB SERVER STATUS] NOT ENABLED or unknown")

    if args.cmd:
        out, err, rc = ssh_run(client, args.cmd)
        print(out or err)
        print(f"[INFO] `{args.cmd}` rc={rc}")
    else:
        print(f"[RESULT] SSH connection to {args.hsm_id} successful.")

    # optional role + user flow (base64 upload to /tmp)
    if args.role_file:
        role_local = os.path.join(ROLES_DIR, args.role_file)
        if not os.path.exists(role_local):
            client.close()
            raise SystemExit(f"[ERROR] Role file not found: {role_local}")
        role_name = os.path.splitext(os.path.basename(role_local))[0]
        new_user = args.new_user or input("New username to create: ").strip()
        temp_pwd = gen_password()

        print(f"[INFO] Uploading role file (base64) to {REMOTE_ROLE} ...")
        upload_via_base64_to_tmp(client, role_local)

        print(f"[INFO] Importing role '{role_name}' (fw={hsm.get('fwVersion')}) ...")
        import_role_firmware_aware(client, hsm, role_name)

        print(f"[INFO] Creating user '{new_user}' ...")
        add_user(client, new_user, temp_pwd)

        print(f"[INFO] Assigning role '{role_name}' to '{new_user}' ...")
        assign_role(client, new_user, role_name)

        print(f"[INFO] Attempting to set temporary password for '{new_user}' ...")
        set_password_interactive(client, new_user, temp_pwd)

        print("\n[RESULT] User created:", new_user)
        print("Temporary password:", temp_pwd)
        print("User must change password at first login (firmware-dependent).")

    client.close()

if __name__ == "__main__":
    main()
