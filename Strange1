#!/usr/bin/env python3
"""
um_rest_api.py

Luna HSM REST User Management Automation (final)

Behavior:
 - Non-interactive CLI (falls back to prompt if password omitted)
 - Env-based new-user mapping (DEV|TE1|TE2|PROD) — same names you provided
 - Strictly tries the API endpoints and payload shapes shown in your screenshots
 - Mandatory certificate flow (CSR -> upload -> restart) attempted using the API variants
 - Creates the REST user, assigns role, stores generated password to resources/user_passwords.json
 - Installs `requests` if missing

Usage example:
  python3 um_rest_api.py --hsm-id hsm01 --env DEV --apiuser admin --apipassword <pw>
"""

import argparse
import os
import sys
import json
import datetime
import secrets
import string
import tempfile
import getpass
import subprocess
from typing import Tuple

# ensure requests is available
try:
    import requests
    import urllib3
except Exception:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"])
    import requests
    import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ----------------------------------------------------------------------
# constants / paths
# ----------------------------------------------------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
PW_STORE = os.path.join(RES_DIR, "user_passwords.json")
os.makedirs(RES_DIR, exist_ok=True)

FIXED_ROLE_NAME = "user_mgmt_role"
CT_V10 = "application/vnd.safenetinc.lunasa+json;version=10"
CT_V7 = "application/vnd.safenetinc.lunasa+json;version=7"

ENV_USER_MAP = {
    "DEV": "svc_at48994_usrmgt",
    "TE1": "svc_at48993_usrmgt",
    "TE2": "svc_at48992_usrmgt",
    "PROD": "svc_at49008_usrmgt"
}

# ----------------------------------------------------------------------
# helpers: password generation + storage
# ----------------------------------------------------------------------
def _generate_temp_password(length: int = 16) -> str:
    alphabet = string.ascii_letters + string.digits + "._-"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def _save_password_for_user(username: str, password: str, category: str = "rest") -> None:
    data = {}
    if os.path.exists(PW_STORE):
        try:
            with open(PW_STORE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            data = {}
    # keep luna shell compatibility: store under a bucket (category) to avoid collisions
    if category not in data:
        data[category] = {}
    data[category][username] = {"password": password, "created_at": datetime.datetime.utcnow().isoformat() + "Z"}
    tmp = PW_STORE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, PW_STORE)
    try:
        os.chmod(PW_STORE, 0o600)
    except Exception:
        pass

# ----------------------------------------------------------------------
# load mapping
# ----------------------------------------------------------------------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in mapping.")

# ----------------------------------------------------------------------
# HTTP wrappers with diagnostics
# ----------------------------------------------------------------------
def try_post(session: requests.Session, url: str, **kwargs) -> Tuple[int, str]:
    try:
        r = session.post(url, verify=False, timeout=30, **kwargs)
        return r.status_code, r.text or ""
    except Exception as e:
        return -1, f"exception:{e}"

def try_put(session: requests.Session, url: str, **kwargs) -> Tuple[int, str]:
    try:
        r = session.put(url, verify=False, timeout=60, **kwargs)
        return r.status_code, r.text or ""
    except Exception as e:
        return -1, f"exception:{e}"

def try_get(session: requests.Session, url: str, **kwargs) -> Tuple[int, str]:
    try:
        r = session.get(url, verify=False, timeout=20, **kwargs)
        return r.status_code, r.text or ""
    except Exception as e:
        return -1, f"exception:{e}"

# ----------------------------------------------------------------------
# login (supports 204 and cookie flows)
# ----------------------------------------------------------------------
def rest_login(session: requests.Session, base_url: str, user: str, pwd: str) -> Tuple[bool, dict]:
    """
    Tries login with v10 Content-Type header first, accepts 200/201/204.
    If cookie-based session is returned, store it in session.cookies (requests does that automatically).
    Returns (ok, response_json_if_any)
    """
    url = f"{base_url}/auth/session"
    headers = {"Content-Type": CT_V10}
    # prefer Basic auth on the session object (some HSMs accept 204 w/out cookie)
    # We'll attach auth per-request as fallback to ensure credentials are used
    try:
        # direct POST with auth tuple (works with curl -u)
        r = session.post(url, auth=(user, pwd), headers=headers, verify=False, timeout=20)
    except Exception as e:
        return False, {"error": str(e)}

    if r.status_code in (200, 201, 204):
        print(f"[INFO] Login succeeded (status: {r.status_code})")
        # if JSON returned, return it
        try:
            return True, r.json()
        except Exception:
            return True, {}
    # try v7 header fallback
    try:
        r2 = session.post(url, auth=(user, pwd), headers={"Content-Type": CT_V7}, verify=False, timeout=20)
    except Exception as e:
        return False, {"error": str(e)}

    if r2.status_code in (200, 201, 204):
        print(f"[INFO] Login succeeded with v7 header (status: {r2.status_code})")
        try:
            return True, r2.json()
        except Exception:
            return True, {}
    # not accepted: return both bodies for debugging
    print(f"[ERROR] Login failed: {r.status_code} / {r2.status_code}")
    print(f"[DEBUG] body1: {r.text[:400]}")
    print(f"[DEBUG] body2: {r2.text[:400]}")
    return False, {"body1": r.text, "body2": r2.text}

# ----------------------------------------------------------------------
# certificate flow (mandatory)
# tries the exact endpoints/patterns from your screenshots in order
# ----------------------------------------------------------------------
def certificate_flow(session: requests.Session, base_url: str) -> bool:
    """
    Sequence (strict):
      1) Try GET/POST on /api/lunasa/webServer/certificate/actions (probe)
      2) Try generate CSR at /api/lunasa/webServer/csr (v10) or /api/lunasa/webServer/csr?version=7
      3) If CSR obtained, upload to /api/lunasa/webServer/certificate via PUT (v10 octet-stream)
      4) For 7.8+ use /api/lunasa/services/webserver/actions/restart (POST)
    This function will raise only if a necessary step absolutely fails (CSR generation/upload).
    """
    # 1) probe actions endpoints (not guaranteed to exist on all builds)
    probe_candidates = [
        f"{base_url}/api/lunasa/webServer/certificate/actions",
        f"{base_url}/api/lunasa/services/webserver/actions",
        f"{base_url}/api/lunasa/services/webserver/actions/restart"
    ]
    for p in probe_candidates:
        code, body = try_get(session, p, headers={"Content-Type": CT_V10})
        print(f"[DEBUG] probe GET {p} -> {code}")
        if code == 200:
            # try POST to trigger if applicable
            pcode, pbody = try_post(session, p, headers={"Content-Type": CT_V10}, json={})
            print(f"[INFO] POST {p} -> {pcode}")
            if pcode in (200, 201, 204):
                return True
    # 2) generate CSR (required step)
    csr_candidates = [
        f"{base_url}/api/lunasa/webServer/csr",
        f"{base_url}/api/lunasa/webServer/csr?version=10",
        f"{base_url}/api/lunasa/webServer/csr?version=7"
    ]
    csr_text = None
    csr_path = None
    for c in csr_candidates:
        print(f"[DEBUG] Attempting CSR generation: {c}")
        code, body = try_post(session, c, headers={"Content-Type": CT_V10}, json={"keyType": "rsa", "keySize": 2048, "cn": base_url})
        print(f"[DEBUG] CSR POST {c} -> {code}")
        if code in (200, 201):
            csr_text = body
            break
    if not csr_text:
        # some builds return CSR via GET after POST trigger - try GET
        for c in csr_candidates:
            code, body = try_get(session, c, headers={"Content-Type": CT_V10})
            print(f"[DEBUG] CSR GET {c} -> {code}")
            if code in (200, 201):
                csr_text = body
                break
    if not csr_text:
        # fail: CSR generation not available
        print("[ERROR] CSR generation failed for all tried endpoints.")
        return False

    # save CSR to temp file so we can PUT as binary (mimic curl --data-binary @file)
    csr_path = os.path.join(RES_DIR, "auto_generated.csr.pem")
    with open(csr_path, "w", encoding="utf-8") as f:
        f.write(csr_text)

    # 3) upload certificate - PUT to certificate endpoints
    cert_put_candidates = [
        f"{base_url}/api/lunasa/webServer/certificate",
        f"{base_url}/api/lunasa/webServer/certificate?version=10",
        f"{base_url}/api/lunasa/services/webserver/certificate"
    ]
    for cp in cert_put_candidates:
        print(f"[DEBUG] Attempting certificate upload to {cp}")
        try:
            with open(csr_path, "rb") as fh:
                files = {"file": fh}
                # some HSMs expect octet-stream and no JSON; emulate curl --data-binary
                code, body = try_put(session, cp, headers={"Content-Type": "application/vnd.safenetinc.lunasa+octet-stream;version=10"}, data=fh.read())
            print(f"[DEBUG] PUT {cp} -> {code}")
            if code in (200, 201, 204):
                # optionally restart webserver for certain versions
                for restart_p in (f"{base_url}/api/lunasa/services/webserver/actions/restart",):
                    rcode, rbody = try_post(session, restart_p, headers={"Content-Type": CT_V10}, json={})
                    print(f"[DEBUG] restart POST {restart_p} -> {rcode}")
                return True
        except Exception as e:
            print(f"[WARN] upload attempt exception {e}")
            continue

    print("[ERROR] Certificate upload failed for all tried endpoints.")
    return False

# ----------------------------------------------------------------------
# create REST user (tries payload variants shown)
# ----------------------------------------------------------------------
def create_rest_user(session: requests.Session, base_url: str, username: str) -> str:
    """
    Try payload shapes:
      - {"userId": "...", "role":"user_mgmt_role", "password":"pw"}  (screenshot)
      - {"user": "...", "password":"pw", "confirmPassword":"pw"}     (alternate shape)
      - fallback to /users /api/users paths
    On success returns generated password string (also saved locally).
    """
    pw = _generate_temp_password()
    attempts = []

    url_main = f"{base_url}/api/lunasa/users"
    payload_a = {"userId": username, "role": FIXED_ROLE_NAME, "password": pw}
    payload_b = {"user": username, "password": pw, "confirmPassword": pw}

    # try main variant A
    code, body = try_post(session, url_main, json=payload_a, headers={"Content-Type": CT_V10})
    print(f"[TRY] POST {url_main} (payloadA) -> {code}")
    attempts.append((url_main, code, body))
    if code in (200, 201):
        _save_password_for_user(username, pw)
        return pw

    # try main variant B
    code, body = try_post(session, url_main, json=payload_b, headers={"Content-Type": CT_V10})
    print(f"[TRY] POST {url_main} (payloadB) -> {code}")
    attempts.append((url_main, code, body))
    if code in (200, 201):
        _save_password_for_user(username, pw)
        return pw

    # alternate paths
    alt_paths = [
        f"{base_url}/users",
        f"{base_url}/api/users",
        f"{base_url}/api/lunasa/users?version=7"
    ]
    for p in alt_paths:
        code, body = try_post(session, p, json=payload_a, headers={"Content-Type": CT_V10})
        print(f"[TRY] POST {p} (payloadA) -> {code}")
        attempts.append((p, code, body))
        if code in (200, 201):
            _save_password_for_user(username, pw)
            return pw
        code, body = try_post(session, p, json=payload_b, headers={"Content-Type": CT_V10})
        print(f"[TRY] POST {p} (payloadB) -> {code}")
        attempts.append((p, code, body))
        if code in (200, 201):
            _save_password_for_user(username, pw)
            return pw

    # nothing worked
    print("[ERROR] User creation failed. Attempts:")
    for u, c, b in attempts:
        print(f"  {u} -> {c} | {str(b)[:200]}")
    raise SystemExit("[FATAL] All user creation attempts failed.")

# ----------------------------------------------------------------------
# assign role (tries assignment endpoints)
# ----------------------------------------------------------------------
def assign_role(session: requests.Session, base_url: str, username: str, role_name: str) -> bool:
    """
    Attempts a variety of patterns for assigning/importing roles:
    - PUT /api/lunasa/roles/{role}/users/{username}
    - POST /api/lunasa/users with role field
    - PUT /api/lunasa/users/{username}/roles/{role}
    """
    tries = []

    p1 = f"{base_url}/api/lunasa/roles/{role_name}/users/{username}"
    code, body = try_put(session, p1, headers={"Content-Type": CT_V10})
    print(f"[TRY] PUT {p1} -> {code}")
    tries.append((p1, code, body))
    if code in (200, 201, 204):
        return True

    p2 = f"{base_url}/api/lunasa/users"
    payload = {"userId": username, "role": role_name}
    code, body = try_post(session, p2, json=payload, headers={"Content-Type": CT_V10})
    print(f"[TRY] POST {p2} (assign role payload) -> {code}")
    tries.append((p2, code, body))
    if code in (200, 201, 204):
        return True

    alt_patterns = [
        f"{base_url}/api/lunasa/users/{username}/roles/{role_name}",
        f"{base_url}/users/{username}/roles/{role_name}",
        f"{base_url}/api/users/{username}/roles/{role_name}"
    ]
    for p in alt_patterns:
        code, body = try_put(session, p, headers={"Content-Type": CT_V10})
        print(f"[TRY] PUT {p} -> {code}")
        tries.append((p, code, body))
        if code in (200, 201, 204):
            return True

    print("[WARN] Role assignment attempts finished; none succeeded. Details:")
    for u, c, b in tries:
        print(f"  {u} -> {c} | {str(b)[:200]}")
    return False

# ----------------------------------------------------------------------
# main
# ----------------------------------------------------------------------
def main():
    p = argparse.ArgumentParser(description="Luna HSM REST user mgmt (final)")
    p.add_argument("--hsm-id", required=True, help="HSM ID from resources/hsm_mapping.json")
    p.add_argument("--env", required=True, choices=["DEV", "TE1", "TE2", "PROD"], type=str.upper)
    p.add_argument("--apiuser", default="admin", help="API login user (default: admin)")
    p.add_argument("--apipassword", help="API login password (optional; will prompt if omitted)")
    args = p.parse_args()

    env = args.env.upper()
    new_user = ENV_USER_MAP.get(env)
    if not new_user:
        raise SystemExit("[ERROR] unsupported env")

    admin_user = args.apiuser
    admin_pwd = args.apipassword or getpass.getpass(f"Password for {admin_user}@HSM API: ")

    # load mapping
    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    if not host:
        raise SystemExit("[ERROR] mapping entry missing host/ip")
    base_url = f"https://{host}:8443"

    session = requests.Session()
    # set session auth to allow 204/no-cookie style logins (requests will send basic auth per-request)
    session.auth = (admin_user, admin_pwd)

    ok, info = rest_login(session, base_url, admin_user, admin_pwd)
    if not ok:
        raise SystemExit("[ERROR] login failed; check credentials and endpoint")

    # mandatory certificate flow: if it fails, abort because you said certificate is required
    print("[INFO] Running certificate flow (mandatory)...")
    cert_ok = certificate_flow(session, base_url)
    if not cert_ok:
        raise SystemExit("[ERROR] certificate flow failed. aborting.")

    # create user (raises on failure)
    print(f"[INFO] Creating REST user '{new_user}' ...")
    pw = create_rest_user(session, base_url, new_user)
    print(f"[INFO] Created user '{new_user}' with generated password saved locally.")

    # assign role (best-effort; reports if failed)
    print(f"[INFO] Assigning role '{FIXED_ROLE_NAME}' to '{new_user}' ...")
    role_ok = assign_role(session, base_url, new_user, FIXED_ROLE_NAME)
    if role_ok:
        print("[SUCCESS] Role assigned.")
    else:
        print("[WARN] Role assignment did not succeed. See debug attempts above.")

    print(f"\n✅ Completed for HSM {args.hsm_id} ({env}). New REST user: {new_user}\n")

if __name__ == "__main__":
    main()
