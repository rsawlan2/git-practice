#!/usr/bin/env python3
"""
luna_with_role_create_temp_password_versioned.py

Minimal, version-aware:
- load HSM mapping by --hsm-id (resources/hsm_mapping.json)
- connect via SSH (prompt username/password)
- check `webserver show`
- create minimal user-management role file, upload & import it
- create a new user with an autogenerated temporary password
- attempt to expire password at first login depending on firmware version:
    * firmware <= 7.4.0: user password <username> will expire the password (script uses this)
    * firmware >= 7.7.0: behavior changed; script will attempt user password <username> and
      detect whether it caused expiry; if not, it will print recommended manual steps
- assign the new custom role to the new user
- run a secondary command (default: "hsm show")

Notes:
- This script intentionally does NOT change global sysconf password expiry settings automatically.
- Citations in code comments reference Thales docs about behavior differences.
"""
import sys, subprocess, getpass, json, os, socket, time, secrets, string, re

# --- Ensure paramiko installed ---
try:
    import paramiko
except ImportError:
    print("[INFO] Installing paramiko...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "paramiko"])
    import paramiko

from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException

RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")

# minimal role content
ROLE_FILENAME = "user_mgmt_role.txt"
ROLE_CONTENT_LINES = [
    "user list",
    "user show",
    "user add",
    "user delete",
    "user enable",
    "user disable",
    "user role add",
    "user role remove",
    "user role list",
    "user role show",
]

# ---------------- Helpers ----------------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in {HSM_FILE}")

def ssh_run(client: SSHClient, cmd: str, timeout: float = 15) -> tuple[str, str, int]:
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    out = stdout.read().decode(errors="ignore")
    err = stderr.read().decode(errors="ignore")
    try:
        rc = stdout.channel.recv_exit_status()
    except Exception:
        rc = -1
    return out, err, rc

def check_webserver_status(client: SSHClient) -> str:
    out, err, rc = ssh_run(client, "webserver show")
    combined = (out + err).lower()
    if "running" in combined or "enabled" in combined:
        return "ENABLED"
    if "not running" in combined or "stopped" in combined or "disabled" in combined:
        return "DISABLED"
    if "permission denied" in combined:
        return "NO_PERMISSION"
    if "not recognized" in combined or "unknown command" in combined:
        return "NOT_SUPPORTED"
    return "UNKNOWN"

def write_role_file(path=ROLE_FILENAME):
    with open(path, "w", newline="\n") as f:
        for line in ROLE_CONTENT_LINES:
            f.write(line.rstrip() + "\n")
    return path

def assert_unix_lf(path):
    with open(path, "rb") as f:
        data = f.read()
    if b"\r\n" in data:
        raise SystemExit("Role file contains CRLF. Convert to UNIX LF (dos2unix) and retry.")
    if not data.strip():
        raise SystemExit("Role file is empty.")

def sftp_upload(client: SSHClient, local_path: str) -> str:
    sftp = client.open_sftp()
    remote_name = os.path.basename(local_path)
    sftp.put(local_path, remote_name)
    sftp.close()
    return remote_name

def run_lunash_cmd(client: SSHClient, cmd: str, timeout: int = 30):
    full = f'lunash -c "{cmd}"'
    out, err, rc = ssh_run(client, full, timeout=timeout)
    return rc, out.strip(), err.strip()

def user_add_interactive_then_password(client: SSHClient, username: str, password: str, timeout=60):
    """
    Open a lunash interactive shell, run user add (feed password prompts),
    then optionally run user password <username> in the same session and capture combined output.
    """
    chan = client.invoke_shell()
    time.sleep(0.35)
    chan.send("lunash\n")
    time.sleep(0.2)

    combined = ""

    # 1) user add -username <username>
    chan.send(f"user add -username {username}\n")
    start = time.time()
    saw_new = saw_retype = False
    buf = ""
    while time.time() - start < timeout:
        if chan.recv_ready():
            chunk = chan.recv(4096).decode(errors="ignore")
            buf += chunk
            low = chunk.lower()
            if ("new password" in low or "enter new password" in low or "new passwd" in low) and not saw_new:
                chan.send(password + "\n"); saw_new = True
            if ("retype new password" in low or "confirm new password" in low) and not saw_retype:
                chan.send(password + "\n"); saw_retype = True
            # break heuristics
            if "created" in buf.lower() or "all authentication tokens updated successfully" in buf.lower():
                break
        time.sleep(0.12)
    combined += "\n--- after user add ---\n" + buf

    # 2) user password <username>  (attempt to set/expire)
    # send it and collect output
    chan.send(f"user password {username}\n")
    start2 = time.time()
    buf2 = ""
    saw_new2 = saw_retype2 = False
    while time.time() - start2 < timeout:
        if chan.recv_ready():
            chunk = chan.recv(4096).decode(errors="ignore")
            buf2 += chunk
            low = chunk.lower()
            if ("new password" in low or "enter new password" in low) and not saw_new2:
                chan.send(password + "\n"); saw_new2 = True
            if ("retype new password" in low or "confirm new password" in low) and not saw_retype2:
                chan.send(password + "\n"); saw_retype2 = True
            # break heuristics
            if "all authentication tokens updated successfully" in buf2.lower() or "changing password" in buf2.lower():
                break
        time.sleep(0.12)
    combined += "\n--- after user password ---\n" + buf2

    try:
        chan.send("exit\n")
    except Exception:
        pass
    return combined

def gen_temp_password(length=14):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def parse_firmware_version_from_hsm_show(client: SSHClient):
    """
    Run `lunash -c "hsm show"` and try to parse a semantic version (major.minor.patch).
    Returns tuple (major, minor, patch) or None if not parseable.
    """
    rc, out, err = run_lunash_cmd(client, "hsm show")
    text = (out + "\n" + err)
    if not text.strip():
        return None
    # common patterns: 'Firmware version: 7.4.1' or 'Version: 7.7.0' etc.
    m = re.search(r"firmware\s+version[:\s]*([0-9]+)\.([0-9]+)\.([0-9]+)", text, flags=re.I)
    if not m:
        m = re.search(r"version[:\s]*([0-9]+)\.([0-9]+)\.([0-9]+)", text, flags=re.I)
    if m:
        return (int(m.group(1)), int(m.group(2)), int(m.group(3)))
    return None

# ---------------- Main ----------------
def main():
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("--hsm-id", required=True, help="HSM ID from mapping JSON")
    p.add_argument("--cmd", default="hsm show", help="Secondary LunaSH command to run")
    p.add_argument("--role-name", required=True, help="Role name to import (e.g. usermgmt)")
    p.add_argument("--new-user", required=True, help="Username to create and assign the role to")
    args = p.parse_args()

    # load mapping
    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))

    # admin creds
    user = input("Username: ").strip()
    pwd = getpass.getpass("Password: ")

    # connect
    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    try:
        print(f"[INFO] Connecting to {host}:{port} as {user} ...")
        client.connect(hostname=host, port=port, username=user, password=pwd, allow_agent=False, look_for_keys=False, timeout=20)
    except AuthenticationException:
        print("[ERROR] Authentication failed.")
        return
    except (SSHException, socket.error) as e:
        print(f"[ERROR] SSH connection failed: {e}")
        return

    # webserver check
    status = check_webserver_status(client)
    print(f"[WEB SERVER STATUS] {status}")

    # write & upload role file
    try:
        role_path = write_role_file()
        assert_unix_lf(role_path)
        print(f"[INFO] Role file created locally: {role_path}")
    except Exception as e:
        print(f"[ERROR] Creating role file failed: {e}")
        client.close()
        return

    try:
        remote_name = sftp_upload(client, role_path)
        print(f"[INFO] Uploaded role file as: {remote_name}")
    except Exception as e:
        print(f"[ERROR] SFTP upload failed: {e}")
        client.close()
        return

    # import role
    print(f"[INFO] Importing role '{args.role_name}' ...")
    rc, out, err = run_lunash_cmd(client, f"user role import -file {remote_name} -role {args.role_name}")
    print(f"[IMPORT] rc={rc}")
    if out: print("[IMPORT OUT]", out)
    if err: print("[IMPORT ERR]", err)
    if rc != 0:
        print("[ERROR] Role import failed. Aborting.")
        client.close()
        return

    # detect firmware version
    ver = parse_firmware_version_from_hsm_show(client)
    if ver:
        print(f"[INFO] Detected firmware version: {ver[0]}.{ver[1]}.{ver[2]}")
    else:
        print("[WARN] Could not parse firmware version (lunash 'hsm show' output). Proceeding but expiry behavior uncertain.")

    # generate temp password and show once
    temp_pw = gen_temp_password(14)
    print(f"[INFO] Temporary password for user '{args.new_user}':\n{temp_pw}\n--- Store this securely and share with user. ---")

    # Create user and try to enforce change-on-first-login depending on version
    try:
        if ver and (ver[0], ver[1], ver[2]) <= (7,4,0):
            # older firmwares: user password <username> expires the password
            print("[INFO] Firmware <= 7.4 detected — using user add then user password <username> (will expire password).")
            combined = user_add_interactive_then_password(client, args.new_user, temp_pw, timeout=60)
            print("[USER CREATE OUTPUT SNIPPET]")
            print("\n".join(combined.splitlines()[-20:]))
            # success — proceed
        else:
            # newer firmware (7.7+ behavior changed) or unknown:
            print("[INFO] Firmware >= 7.7 or unknown. Creating user and attempting to expire password; if expiry not enforced, script will indicate manual steps.")
            # run interactive flow (user add + user password) and inspect output for expiry hints
            combined = user_add_interactive_then_password(client, args.new_user, temp_pw, timeout=60)
            print("[USER CREATE/SET OUTPUT SNIPPET]")
            print("\n".join(combined.splitlines()[-20:]))
            low = combined.lower()
            # heuristics: check for phrases that indicate expiry was set
            if "must change" in low or "must change password" in low or "expire" in low or "all authentication tokens updated successfully" in low:
                print("[INFO] Detected text suggesting the password is expired/needs change at next login.")
            else:
                # couldn't confirm expiry; warn operator and provide manual steps
                print("\n[WARN] Could not confirm that the password was forced to expire on first login for this firmware.")
                print("If you require the user to change password at first login, do one of the following manually on the appliance:")
                print("  1) Run (if supported) and verify: lunash:> user password <username>  (enter new password) — on some firmwares this expires the password.")
                print("  2) If your firmware supports setting global expiry policy, you can use: lunash:> sysconf user password expire <days>")
                print("     (Be careful: this changes the global policy for all appliance users.)")
                print("  3) Check appliance docs for your firmware version; run: lunash:> hsm show  and consult Thales docs for 'user password' behavior.")
                print("\n[NOTE] Detected firmware version (if parsed):", f"{ver[0]}.{ver[1]}.{ver[2]}" if ver else "UNKNOWN")
                print("If you tell me your exact firmware string (output of: lunash -c \"hsm show\"), I can update the script to force expiry in a safe, version-appropriate way.")
    except Exception as e:
        print(f"[ERROR] Interactive user creation/password set failed: {e}")
        client.close()
        return

    # assign role
    print(f"[INFO] Assigning role '{args.role_name}' to user '{args.new_user}' ...")
    rc2, out2, err2 = run_lunash_cmd(client, f"user role add -username {args.new_user} -role {args.role_name}")
    print(f"[ROLE ADD] rc={rc2}")
    if out2: print("[ROLE ADD OUT]", out2)
    if err2: print("[ROLE ADD ERR]", err2)
    if rc2 != 0:
        print("[ERROR] Role assignment failed.")
        client.close()
        return

    # final verification: run secondary command
    try:
        out3, err3, rc3 = ssh_run(client, args.cmd)
        print(f"\n--- Output of `{args.cmd}` ---")
        print(out3)
        if err3:
            print("--- STDERR ---")
            print(err3)
        print(f"[INFO] `{args.cmd}` exited with code {rc3}")
    except Exception as e:
        print(f"[ERROR] Running `{args.cmd}` failed: {e}")

    client.close()
    print("Done — role created, user created (temp pw set), role assigned. ✨")
    print("If the script could not confirm expiry, see the WARN notes above or share your appliance firmware string and I'll patch the script to force expiry safely.")

if __name__ == "__main__":
    main()
