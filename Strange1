#!/usr/bin/env python3
"""
Luna HSM REST User Management Automation
----------------------------------------------------------------------
Purpose:
    Automates REST API–based user creation and role assignment,
    matching the LunaSH script behavior but using REST endpoints.
    Adapts automatically to certificate handling differences.

Features:
    • Reads HSM details from resources/hsm_mapping.json
    • Handles SSL certificate regeneration or CSR upload
    • Creates REST user (env-based naming)
    • Assigns minimal custom user management role
    • Saves passwords locally under 'rest' section
----------------------------------------------------------------------

"""

import argparse
import os
import json
import datetime
import secrets
import string
import subprocess
import getpass
import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ----------------------------------------------------------------------
# Auto-install dependency if missing
# ----------------------------------------------------------------------
try:
    import requests  # noqa: F401
except ImportError:
    print("[INFO] Installing dependencies (requests)...")
    subprocess.check_call(["pip", "install", "requests"])
    import requests

# ----------------------------------------------------------------------
# Constants and paths
# ----------------------------------------------------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
PW_STORE = os.path.join(RES_DIR, "user_passwords.json")
os.makedirs(RES_DIR, exist_ok=True)

FIXED_ROLE_NAME = "user_mgmt_role"
DEFAULT_CT = "application/vnd.safenetinc.lunasa+json;version=10"

ENV_USER_MAP = {
    "DEV": "svc_at48994_usrmgt",
    "TE1": "svc_at48993_usrmgt",
    "TE2": "svc_at48992_usrmgt",
    "PROD": "svc_at49008_usrmgt"
}

# ----------------------------------------------------------------------
# Utility: password generation + storage
# ----------------------------------------------------------------------
def _generate_temp_password(length=16):
    alphabet = string.ascii_letters + string.digits + "._-"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def _save_password_for_user(username, password, category="rest"):
    data = {}
    if os.path.exists(PW_STORE):
        try:
            with open(PW_STORE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            data = {}
    if category not in data:
        data[category] = {}
    data[category][username] = {"password": password, "created_at": datetime.datetime.utcnow().isoformat() + "Z"}
    tmp = PW_STORE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, PW_STORE)

# ----------------------------------------------------------------------
# Load HSM mapping
# ----------------------------------------------------------------------
def load_hsm(hsm_id):
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in mapping.")

# ----------------------------------------------------------------------
# REST session utilities
# ----------------------------------------------------------------------
def rest_login(session, base_url, user, pwd):
    url = f"{base_url}/auth/session"
    headers = {"Content-Type": DEFAULT_CT}
    r = session.post(url, auth=(user, pwd), headers=headers, verify=False, timeout=20)

    # 204 = success (no content), 200/201 = success too
    if r.status_code in (200, 201, 204):
        print(f"[INFO] Login succeeded (status: {r.status_code})")
        return
    raise SystemExit(f"[ERROR] Login failed ({r.status_code}): {r.text}")

def rest_logout(session, base_url):
    try:
        session.delete(f"{base_url}/auth/session", verify=False, timeout=10)
    except Exception:
        pass

# ----------------------------------------------------------------------
# Certificate handling
# ----------------------------------------------------------------------
def setup_certificate(session, base_url):
    print("[INFO] Checking certificate actions...")
    actions_url = f"{base_url}/api/lunasa/webServer/certificate/actions"
    r = session.get(actions_url, verify=False, timeout=20)
    if r.status_code != 200:
        print(f"[WARN] Could not fetch certificate actions (status {r.status_code}). Trying CSR flow...")
        return generate_and_upload_csr(session, base_url)

    actions = r.json().get("actions", {})
    regen_url = None
    for act in actions:
        if "regenerate" in str(act).lower():
            regen_url = actions[act] if isinstance(actions, dict) else act
            break

    if regen_url:
        print("[INFO] Regenerate action found. Regenerating certificate...")
        full = regen_url if regen_url.startswith("http") else base_url + regen_url
        pr = session.post(full, json={}, headers={"Content-Type": DEFAULT_CT}, verify=False, timeout=60)
        if pr.status_code in (200, 201, 204):
            print("[INFO] Certificate regenerated successfully.")
            return True
        else:
            print(f"[WARN] Regen failed ({pr.status_code}). Fallback to CSR flow.")
    return generate_and_upload_csr(session, base_url)

def generate_and_upload_csr(session, base_url):
    print("[INFO] Generating CSR via API...")
    csr_url = f"{base_url}/api/lunasa/webServer/csr"
    r = session.post(csr_url, json={}, headers={"Content-Type": DEFAULT_CT}, verify=False, timeout=30)
    if r.status_code not in (200, 201):
        print(f"[ERROR] CSR generation failed ({r.status_code}): {r.text}")
        return False

    csr_data = r.text.strip()
    csr_path = os.path.join(RES_DIR, "generated_csr.pem")
    with open(csr_path, "w", encoding="utf-8") as f:
        f.write(csr_data)
    print(f"[INFO] CSR saved to {csr_path}. Using self-signed mode for upload...")

    cert_url = f"{base_url}/api/lunasa/webServer/certificate"
    pr = session.put(cert_url, files={"file": open(csr_path, "rb")}, verify=False, timeout=30)
    if pr.status_code in (200, 201, 204):
        print("[INFO] Certificate uploaded successfully.")
    else:
        print(f"[WARN] Certificate upload failed ({pr.status_code}): {pr.text}")
    return True

# ----------------------------------------------------------------------
# Create REST user
# ----------------------------------------------------------------------
def create_rest_user(session, base_url, username):
    pw = _generate_temp_password()
    payload = {"user": username, "password": pw, "confirmPassword": pw}
    url = f"{base_url}/api/lunasa/users"
    r = session.post(url, json=payload, headers={"Content-Type": DEFAULT_CT}, verify=False, timeout=20)
    if r.status_code in (200, 201):
        print(f"[INFO] REST user '{username}' created successfully.")
        _save_password_for_user(username, pw)
        return pw
    elif "exists" in r.text.lower():
        print(f"[WARN] User '{username}' already exists.")
        return pw
    else:
        raise SystemExit(f"[ERROR] User creation failed ({r.status_code}): {r.text}")

# ----------------------------------------------------------------------
# Assign role
# ----------------------------------------------------------------------
def assign_role(session, base_url, username, role_name):
    url = f"{base_url}/api/lunasa/roles/{role_name}/users/{username}"
    r = session.put(url, headers={"Content-Type": DEFAULT_CT}, verify=False, timeout=20)
    if r.status_code in (200, 201, 204):
        print(f"[INFO] Role '{role_name}' assigned to '{username}'.")
        return True
    print(f"[ERROR] Role assignment failed ({r.status_code}): {r.text}")
    return False

# ----------------------------------------------------------------------
# Main logic
# ----------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description="Luna HSM REST User Management (v1)")
    parser.add_argument("--hsm-id", required=True, help="HSM ID from mapping file.")
    parser.add_argument("--env", required=True, choices=["DEV", "TE1", "TE2", "PROD"],
                        type=str.upper, help="Environment name.")
    parser.add_argument("--apiuser", default="admin", help="API username (default: admin).")
    parser.add_argument("--apipassword", help="API password (optional; will prompt if missing).")
    args = parser.parse_args()

    env = args.env.upper()
    new_user = ENV_USER_MAP.get(env)
    if not new_user:
        raise SystemExit(f"[ERROR] Unsupported env '{env}'. Valid: DEV, TE1, TE2, PROD")

    admin_user = args.apiuser
    admin_pwd = args.apipassword or getpass.getpass(f"Password for {admin_user}@API: ")

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    base_url = f"https://{host}:8443"

    session = requests.Session()

    try:
        rest_login(session, base_url, admin_user, admin_pwd)
        setup_certificate(session, base_url)
        pw = create_rest_user(session, base_url, new_user)
        assign_role(session, base_url, new_user, FIXED_ROLE_NAME)
        print(f"\n✅ [SUCCESS] Completed for HSM {args.hsm_id} ({env})\n")
    finally:
        rest_logout(session, base_url)

# ----------------------------------------------------------------------
if __name__ == "__main__":
    main()
