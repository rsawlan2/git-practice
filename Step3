#!/usr/bin/env python3
"""
luna_user_mgmt.py

- Reads HSM mapping from resources/hsm_mapping.json
- Single username/password prompt (used for SSH)
- Connects via SSH to HSM
- If --cmd is passed, runs it; if not, confirms successful connection
- Always checks webserver status
- Optional: upload/import custom role file (resources/roles/), create user, assign role,
            and attempt to set temporary password so user must change at first login.

This version adds firmware-aware role import:
 - For fw >= 7.8.0 uses:  user role import -roleName <role> -file <path>
 - For older firmware uses: user role import <role> <path>
 - If version is missing or the first attempt fails, the fallback syntax will be tried once.
"""

from __future__ import annotations
import os, sys, json, socket, time, getpass, argparse, secrets, string, base64, subprocess
from typing import Tuple

# Ensure paramiko installed
try:
    import paramiko
except ImportError:
    print("[INFO] Installing paramiko...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "paramiko"])
    import paramiko

from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException

# Paths relative to script
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
RES_DIR = os.path.join(BASE_DIR, "resources")
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
ROLES_DIR = os.path.join(RES_DIR, "roles")

DEFAULT_REMOTE_ROLE_PATH = "/tmp/roledef.txt"
SSH_TIMEOUT = 20.0


# -------------------------
# Version helper
# -------------------------
def parse_version_tuple(s: str) -> Tuple[int, ...]:
    """Parse version strings like '7.8.0-1' -> (7,8,0). Non-numeric parts stripped."""
    s = (s or "").split("-")[0].strip()
    if not s:
        return tuple()
    parts = []
    for p in s.split("."):
        try:
            parts.append(int(p))
        except Exception:
            parts.append(0)
    return tuple(parts)


def is_fw_at_least(fw: str, cmp_to: str = "7.8.0") -> bool:
    """Return True if fw >= cmp_to (semantic-ish comparison)."""
    if not fw:
        return False
    try:
        return parse_version_tuple(fw) >= parse_version_tuple(cmp_to)
    except Exception:
        return False


# -------------------------
# Helpers
# -------------------------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in {HSM_FILE}")


def ssh_connect(host: str, port: int, user: str, pwd: str, timeout: float = SSH_TIMEOUT) -> SSHClient:
    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    try:
        client.connect(hostname=host, port=port, username=user, password=pwd,
                       allow_agent=False, look_for_keys=False, timeout=timeout)
        return client
    except AuthenticationException:
        raise SystemExit("[ERROR] Authentication failed (check username/password).")
    except (SSHException, socket.error) as e:
        raise SystemExit(f"[ERROR] SSH connection failed: {e}")


def ssh_run(client: SSHClient, cmd: str, timeout: float = 15.0):
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    out = stdout.read().decode(errors="ignore") if stdout else ""
    err = stderr.read().decode(errors="ignore") if stderr else ""
    try:
        rc = stdout.channel.recv_exit_status()
    except Exception:
        rc = -1
    return out, err, rc


def check_webserver_status(client: SSHClient) -> str:
    out, err, rc = ssh_run(client, "webserver show")
    combined = (out + err).lower()
    if "running" in combined or "enabled" in combined:
        return "ENABLED"
    if "not running" in combined or "stopped" in combined or "disabled" in combined:
        return "DISABLED"
    if "permission denied" in combined or "not authorized" in combined:
        return "NO_PERMISSION"
    if "not recognized" in combined or "unknown command" in combined:
        return "NOT_SUPPORTED"
    return "UNKNOWN"


def gen_password(length: int = 16) -> str:
    chars = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    while True:
        p = ''.join(secrets.choice(chars) for _ in range(length))
        if (any(c.islower() for c in p) and any(c.isupper() for c in p)
                and any(c.isdigit() for c in p) and any(c in "!@#$%^&*()-_=+" for c in p)):
            return p


def sh_escape(s: str) -> str:
    return "'" + s.replace("'", "'\"'\"'") + "'"


# -------------------------
# Role/User helpers (firmware-aware import)
# -------------------------
def upload_role_file(client: SSHClient, local_file: str, remote_file: str = DEFAULT_REMOTE_ROLE_PATH) -> str:
    if not os.path.exists(local_file):
        raise SystemExit(f"[ERROR] Role file not found: {local_file}")
    try:
        sftp = client.open_sftp()
        sftp.put(local_file, remote_file)
        sftp.close()
        print(f"[INFO] Uploaded role file via SFTP to {remote_file}")
        return remote_file
    except Exception:
        print("[WARN] SFTP failed, falling back to base64 upload.")

    with open(local_file, "rb") as fh:
        b64 = base64.b64encode(fh.read()).decode()
    remote_b64 = remote_file + ".b64"
    client.exec_command(f"rm -f {remote_file} {remote_b64}")
    chunk_size = 1200
    for i in range(0, len(b64), chunk_size):
        chunk = b64[i:i+chunk_size]
        client.exec_command(f"printf '%s' {sh_escape(chunk)} >> {remote_b64}")
    client.exec_command(f"base64 -d {remote_b64} > {remote_file}")
    client.exec_command(f"rm -f {remote_b64}")
    print(f"[INFO] Uploaded role file via base64 to {remote_file}")
    return remote_file


def import_role(client: SSHClient, hsm: dict, role_name: str, remote_path: str) -> None:
    """
    Firmware-aware import:
      - If fwVersion >= 7.8.0 use: user role import -roleName <role> -file <path>
      - Else use: user role import <role> <path>
    If the chosen syntax fails, attempt the alternate syntax once as a fallback.
    """
    fw = hsm.get("fwVersion") or ""
    use_new = is_fw_at_least(fw, "7.8.0")

    tried = []
    last_err = None

    def _try(cmd: str) -> Tuple[bool, str]:
        out, err, rc = ssh_run(client, cmd)
        combined = (out + err).lower()
        success = (rc == 0) and ("error" not in combined and "syntax" not in combined)
        msg = out or err
        return success, msg

    # build candidate commands in preferred order
    candidates = []
    if use_new:
        candidates.append(f"user role import -roleName {role_name} -file {remote_path}")
        candidates.append(f"user role import {role_name} {remote_path}")
    else:
        candidates.append(f"user role import {role_name} {remote_path}")
        candidates.append(f"user role import -roleName {role_name} -file {remote_path}")

    for cmd in candidates:
        tried.append(cmd)
        success, msg = _try(cmd)
        if success:
            print(f"[INFO] Role '{role_name}' imported successfully using: {cmd}")
            return
        last_err = msg
        print(f"[WARN] Role import attempt failed ({cmd}): {msg.strip()}")

    # all attempts failed
    raise SystemExit(f"[ERROR] Role import failed after trying syntaxes.\nTried: {tried}\nLast error: {last_err}")


def add_user(client: SSHClient, username: str, password: str):
    out, err, rc = ssh_run(client, f"user add -userName {username} -password {password}")
    if rc != 0:
        raise SystemExit(f"[ERROR] Add user failed: {out or err}")
    print(f"[INFO] User '{username}' created.")


def assign_role(client: SSHClient, username: str, role_name: str):
    out, err, rc = ssh_run(client, f"user role add {username} {role_name}")
    if rc != 0:
        raise SystemExit(f"[ERROR] Assign role failed: {out or err}")
    print(f"[INFO] Role '{role_name}' assigned to '{username}'.")


def force_password_set_interactive(client: SSHClient, username: str, password: str, timeout: float = 5.0):
    chan = client.invoke_shell()
    time.sleep(0.2)
    chan.send(f"user password -userName {username}\n")
    time.sleep(0.2)
    chan.send(password + "\n")
    time.sleep(0.2)
    chan.send(password + "\n")
    buff = ""
    start = time.time()
    while time.time() - start < timeout:
        if chan.recv_ready():
            buff += chan.recv(4096).decode(errors="ignore")
        else:
            time.sleep(0.05)
    chan.close()
    if "permission denied" in buff.lower() or "not authorized" in buff.lower():
        raise SystemExit(f"[ERROR] Setting password failed: {buff.strip()}")
    print(f"[INFO] Password set for '{username}' (will need to change at first login).")


# -------------------------
# Main
# -------------------------
def main():
    p = argparse.ArgumentParser()
    p.add_argument("--hsm-id", required=True, help="HSM ID from mapping JSON")
    p.add_argument("--cmd", help="Optional LunaSH command to run (if omitted, just confirm connection)")
    p.add_argument("--role-file", help="Optional role filename inside resources/roles/")
    p.add_argument("--new-user", help="Optional new username to create (if omitted, will prompt)")
    args = p.parse_args()

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))

    user = input("Username: ").strip()
    pwd = getpass.getpass("Password: ")

    print(f"[INFO] Connecting to {host}:{port} as {user} ...")
    client = ssh_connect(host, port, user, pwd)

    # always check webserver
    ws_status = check_webserver_status(client)
    print(f"[WEB SERVER STATUS] {ws_status}")

    # run cmd if provided, else just confirm connection
    if args.cmd:
        out, err, rc = ssh_run(client, args.cmd)
        print(f"\n--- Output of `{args.cmd}` ---")
        if out: print(out.strip())
        if err: print("--- STDERR ---\n" + err.strip())
        print(f"[INFO] `{args.cmd}` exited with code {rc}")
    else:
        print(f"[RESULT] SSH connection to {args.hsm_id} successful.")

    # optional role/user flow
    if args.role_file:
        role_local_path = os.path.join(ROLES_DIR, args.role_file)
        role_name = os.path.splitext(os.path.basename(role_local_path))[0]

        if not os.path.exists(role_local_path):
            client.close()
            raise SystemExit(f"[ERROR] Role file not found: {role_local_path}")

        new_user = args.new_user or input("New username to create: ").strip()
        temp_pwd = gen_password()

        print(f"[INFO] Uploading role file '{role_local_path}' ...")
        remote_role_path = upload_role_file(client, role_local_path)

        print(f"[INFO] Importing role '{role_name}' (fwVersion={hsm.get('fwVersion')}) ...")
        import_role(client, hsm, role_name, remote_role_path)

        print(f"[INFO] Creating user '{new_user}' ...")
        add_user(client, new_user, temp_pwd)

        print(f"[INFO] Assigning role '{role_name}' to '{new_user}' ...")
        assign_role(client, new_user, role_name)

        print(f"[INFO] Attempting to set temporary password for '{new_user}' ...")
        force_password_set_interactive(client, new_user, temp_pwd)

        print("\n[RESULT] User created:", new_user)
        print("Temporary password:", temp_pwd)
        print("User must change password at first login (firmware-dependent).")

    client.close()


if __name__ == "__main__":
    main()
