#!/usr/bin/env python3
"""
luna_create_user_mgmt_role_and_user_rest_versioned.py

- Reads HSM mapping from resources/hsm_mapping.json using --hsm-id
  (if mapping contains "apiVersion" or "restApiVersion" that value is used)
- Connects via SSH (prompt admin username/password)
- Checks webserver status / API version as fallback
- Creates a minimal user_mgmt role file locally
- Tries to upload via SFTP -> scp -> REST (REST uses vendor Content-Type with API version)
- Imports role, prompts for new username, creates user with autogenerated temp password,
  attempts to force change-on-first-login (version-aware), assigns role and verifies.
"""
from __future__ import annotations
import argparse, getpass, json, os, re, secrets, string, subprocess, sys, time
from typing import Optional

# dependencies
try:
    import paramiko
except Exception:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "paramiko"])
    import paramiko

try:
    import requests
except Exception:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "requests"])
    import requests

from paramiko import SSHClient, AutoAddPolicy, AuthenticationException, SSHException
from requests.auth import HTTPBasicAuth

RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")

ROLE_NAME = "user_mgmt"
ROLE_FILENAME = "user_mgmt_role.txt"
ROLE_CONTENT_LINES = [
    "user list",
    "user show",
    "user add",
    "user delete",
    "user enable",
    "user disable",
    "user role add",
    "user role remove",
    "user role list",
    "user role show",
]

SSH_TIMEOUT = 20

# ---------- helpers ----------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in {HSM_FILE}")

def ssh_run(client: SSHClient, cmd: str, timeout: float = 15):
    stdin, stdout, stderr = client.exec_command(cmd, timeout=timeout)
    out = stdout.read().decode(errors="ignore")
    err = stderr.read().decode(errors="ignore")
    try:
        rc = stdout.channel.recv_exit_status()
    except Exception:
        rc = -1
    return out, err, rc

def write_role_file(path=ROLE_FILENAME):
    with open(path, "w", newline="\n") as f:
        for line in ROLE_CONTENT_LINES:
            f.write(line.rstrip() + "\n")
    return path

def assert_unix_lf(path):
    with open(path, "rb") as f:
        data = f.read()
    if b"\r\n" in data:
        raise SystemExit("Role file contains CRLF. Convert to UNIX LF (dos2unix) and retry.")
    if not data.strip():
        raise SystemExit("Role file is empty.")

# SFTP upload (Paramiko)
def sftp_upload(client: SSHClient, local_path: str) -> str:
    sftp = client.open_sftp()
    remote = os.path.basename(local_path)
    sftp.put(local_path, remote)
    sftp.close()
    return remote

# scp fallback
def scp_upload(local_path: str, admin_user: str, host: str, port: int, remote_name: str) -> bool:
    scp_target = f"{admin_user}@{host}:{remote_name}"
    cmd = ["scp", "-P", str(port), local_path, scp_target]
    print("[INFO] Running scp:", " ".join(cmd))
    try:
        rc = subprocess.run(cmd).returncode
        return rc == 0
    except FileNotFoundError:
        print("[ERROR] scp not found on this host.")
        return False

# REST upload using vendor content-type and detected api_version
def rest_upload_with_version(host: str, web_port: int, admin_user: str, admin_pass: str,
                             local_path: str, api_version: int) -> bool:
    base = f"https://{host}:{web_port}"
    sess = requests.Session()
    sess.verify = False
    sess.auth = HTTPBasicAuth(admin_user, admin_pass)
    vendor_ct = f"application/vnd.safenetinc.lunasa+multipart;version={api_version}"
    headers = {"Accept": "application/json", "Content-Type": vendor_ct}

    # try username path first
    username_path = f"{base}/api/users/{admin_user}/files"
    print("[INFO] Trying REST upload to (username path):", username_path)
    try:
        with open(local_path, "rb") as f:
            files = {"file": (os.path.basename(local_path), f)}
            r = sess.post(username_path, headers=headers, files=files, timeout=30)
        print("[REST] status", r.status_code, r.reason)
        if 200 <= r.status_code < 300:
            print("[REST] upload succeeded (username path).")
            return True
        print("[REST] body:", r.text[:800])
    except Exception as e:
        print("[REST] username-path request error:", e)

    # if username path failed, try numeric-id lookup via /api/users
    try:
        users_url = f"{base}/api/users"
        print("[INFO] Querying", users_url)
        r = sess.get(users_url, timeout=15)
        if r.ok:
            try:
                js = r.json()
                candidates = []
                if isinstance(js, list):
                    for u in js:
                        uid = u.get("id") or u.get("userId")
                        uname = u.get("username") or u.get("name") or u.get("login")
                        if uid and uname:
                            candidates.append((uid, uname))
                elif isinstance(js, dict):
                    data = js.get("data") or js.get("users") or []
                    if isinstance(data, list):
                        for u in data:
                            uid = u.get("id") or u.get("userId")
                            uname = u.get("username") or u.get("name") or u.get("login")
                            if uid and uname:
                                candidates.append((uid, uname))
                # try matches for admin_user first
                for uid, uname in candidates:
                    if uname.lower() == admin_user.lower():
                        ep = f"{base}/api/users/{uid}/files"
                        print("[INFO] Trying numeric-id endpoint:", ep)
                        with open(local_path, "rb") as f:
                            files = {"file": (os.path.basename(local_path), f)}
                            r2 = sess.post(ep, headers=headers, files=files, timeout=30)
                        print("[REST] numeric-id status", r2.status_code)
                        print("[REST] body:", r2.text[:800])
                        if 200 <= r2.status_code < 300:
                            print("[REST] upload succeeded (numeric-id).")
                            return True
            except ValueError:
                print("[REST] /api/users returned non-json; status", r.status_code)
        else:
            print("[REST] GET /api/users failed:", r.status_code)
    except Exception as e:
        print("[REST] numeric ID flow error:", e)

    return False

def parse_firmware_api_version_from_webserver(client: SSHClient) -> Optional[int]:
    out, err, rc = ssh_run(client, "webserver show")
    text = out + "\n" + err
    # look for 'API Version: 7' or similar
    m = re.search(r"API\s+Version[:\s]*([0-9]+)", text, flags=re.I)
    if m:
        return int(m.group(1))
    # fallback: parse from hsm show if present
    m2 = re.search(r"version[:\s]*([0-9]+)\.([0-9]+)\.([0-9]+)", text, flags=re.I)
    if m2:
        return int(m2.group(1))
    return None

def gen_temp_password(length=14):
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def user_add_interactive_then_password(client: SSHClient, username: str, password: str, timeout=60):
    chan = client.invoke_shell()
    time.sleep(0.3)
    chan.send("lunash\n")
    time.sleep(0.2)
    out = ""
    chan.send(f"user add -username {username}\n")
    start = time.time()
    saw_new = saw_retype = False
    buf = ""
    while time.time() - start < timeout:
        if chan.recv_ready():
            chunk = chan.recv(4096).decode(errors="ignore")
            buf += chunk
            low = chunk.lower()
            if ("new password" in low or "enter new password" in low) and not saw_new:
                chan.send(password + "\n"); saw_new = True
            if ("retype new password" in low or "confirm new password" in low) and not saw_retype:
                chan.send(password + "\n"); saw_retype = True
            if "created" in buf.lower() or "all authentication tokens updated successfully" in buf.lower():
                break
        time.sleep(0.12)
    out += "\n--- after add ---\n" + buf

    chan.send(f"user password {username}\n")
    start2 = time.time()
    buf2 = ""
    saw_new2 = saw_retype2 = False
    while time.time() - start2 < timeout:
        if chan.recv_ready():
            chunk = chan.recv(4096).decode(errors="ignore")
            buf2 += chunk
            low = chunk.lower()
            if ("new password" in low or "enter new password" in low) and not saw_new2:
                chan.send(password + "\n"); saw_new2 = True
            if ("retype new password" in low or "confirm new password" in low) and not saw_retype2:
                chan.send(password + "\n"); saw_retype2 = True
            if "all authentication tokens updated successfully" in buf2.lower() or "changing password" in buf2.lower():
                break
        time.sleep(0.12)
    out += "\n--- after password ---\n" + buf2
    try:
        chan.send("exit\n")
    except Exception:
        pass
    return out

# -------------- main --------------
def main():
    p = argparse.ArgumentParser()
    p.add_argument("--hsm-id", required=True)
    p.add_argument("--cmd", default="hsm show")
    args = p.parse_args()

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    # admin supplied API version in mapping wins:
    mapping_api_version = None
    for k in ("apiVersion", "restApiVersion", "apiversion"):
        if k in hsm and hsm.get(k):
            try:
                mapping_api_version = int(hsm.get(k))
                print(f"[INFO] Using api version from mapping: {mapping_api_version}")
            except Exception:
                pass

    admin_user = input("Admin SSH username: ").strip()
    admin_pass = getpass.getpass("Admin SSH password: ")

    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())
    try:
        print(f"[INFO] Connecting to {host}:{port} as {admin_user} ...")
        client.connect(hostname=host, port=port, username=admin_user, password=admin_pass,
                       allow_agent=False, look_for_keys=False, timeout=SSH_TIMEOUT)
    except AuthenticationException:
        print("[ERROR] Authentication failed.")
        return
    except (SSHException, Exception) as e:
        print("[ERROR] SSH connection failed:", e)
        return

    # webserver status + fallback API version detection
    api_version = mapping_api_version
    if api_version is None:
        api_version = parse_firmware_api_version_from_webserver(client)
        if api_version:
            print(f"[INFO] Detected API version from webserver: {api_version}")
        else:
            print("[WARN] Could not detect API version; defaulting to 7")
            api_version = 7

    # create role file
    try:
        role_path = write_role_file()
        assert_unix_lf(role_path)
        print(f"[INFO] Role file created locally at {role_path}")
    except Exception as e:
        print("[ERROR] creating role file:", e)
        client.close()
        return

    # try SFTP upload first
    uploaded = False
    remote_name = os.path.basename(role_path)
    try:
        remote_name = sftp_upload(client, role_path)
        print("[INFO] Uploaded via SFTP as", remote_name)
        uploaded = True
    except Exception as e:
        print("[INFO] SFTP failed:", e)
        print("[INFO] Trying scp fallback...")
        if scp_upload(role_path, admin_user, host, port, remote_name):
            print("[INFO] scp succeeded.")
            uploaded = True
        else:
            print("[INFO] scp failed or unavailable. Trying REST upload using API version", api_version)
            try:
                # web port: try to detect from webserver show output; default 8443
                web_port = 8443
                # try parse port from webserver show too
                out, err, _ = ssh_run(client, "webserver show")
                mport = re.search(r"Port[:\s]*([0-9]+)", out + err, flags=re.I)
                if mport:
                    web_port = int(mport.group(1))
                rest_ok = rest_upload_with_version(host, web_port, admin_user, admin_pass, role_path, api_version)
                if rest_ok:
                    uploaded = True
                else:
                    print("[ERROR] REST upload attempts failed.")
            except Exception as e2:
                print("[ERROR] REST upload error:", e2)

    if not uploaded:
        print("[ERROR] All upload methods failed. Please upload role file manually and re-run.")
        client.close()
        return

    # import role
    rc, out, err = ssh_run(client, f'lunash -c "user role import -file {remote_name} -role {ROLE_NAME}"', timeout=30)
    print("[IMPORT] rc", rc)
    if out: print(out)
    if err: print(err)
    if rc != 0:
        print("[ERROR] Role import failed.")
        client.close()
        return

    print(f"[OK] Custom role '{ROLE_NAME}' created.")

    # prompt username
    new_user = input("Enter username to create and assign to role 'user_mgmt': ").strip()
    if not new_user:
        print("[ERROR] No username provided.")
        client.close()
        return

    # generate temp pw and create user
    temp_pw = gen_temp_password(14)
    print(f"[INFO] Temporary password for '{new_user}': {temp_pw} (store securely)")

    try:
        combined = user_add_interactive_then_password(client, new_user, temp_pw, timeout=60)
        print("[USER CREATE OUTPUT SNIPPET]")
        print("\n".join(combined.splitlines()[-20:]))
    except Exception as e:
        print("[ERROR] user creation failed:", e)
        client.close()
        return

    # assign role
    rc2, out2, err2 = ssh_run(client, f'lunash -c "user role add -username {new_user} -role {ROLE_NAME}"', timeout=20)
    print("[ROLE ADD] rc", rc2)
    if out2: print(out2)
    if err2: print(err2)
    if rc2 != 0:
        print("[ERROR] Role assignment failed.")
        client.close()
        return

    # verify
    rcv, outv, errv = ssh_run(client, f'lunash -c "user role list -username {new_user}"', timeout=20)
    print("\n--- Verification: user role list ---")
    if outv:
        print(outv)
    elif errv:
        print(errv)
    else:
        print(f"[INFO] Command returned rc={rcv} with no output.")

    # optional cmd
    try:
        out3, err3, rc3 = ssh_run(client, args.cmd)
        print(f"\n--- Output of `{args.cmd}` ---")
        print(out3)
        if err3:
            print("--- STDERR ---")
            print(err3)
    except Exception as e:
        print("[ERROR] Running final cmd:", e)

    client.close()
    print("Done — role created, user created (temp pw set), and assigned to user_mgmt.")

if __name__ == "__main__":
    main()
