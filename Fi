#!/usr/bin/env python3
"""
user_mgmt.py

Automates creation of a user-management role + user on Luna HSMs.

Added flags:
  --dry-run    : Show what would happen, but do nothing
  --test-ssh   : Test SSH login only (runs user list), then exit
"""

# --- Dependency bootstrap ---
try:
    import asyncssh, portalocker
except ImportError:
    import subprocess, sys
    print("[INFO] Installing required dependencies (asyncssh, portalocker)...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "asyncssh", "portalocker"])
    import asyncssh, portalocker

import os, json, asyncio, secrets, string, random, getpass

# ----------------------------
# Config
# ----------------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")
VERSION_FILE = os.path.join(RES_DIR, "version_map.json")
ROLES_DIR = os.path.join(RES_DIR, "roles")
FAILED_LOG = os.path.join(RES_DIR, "failed_jobs.jsonl")
DEFAULT_ROLE_FILE = "user_mgmt_role.txt"

SSH_RETRIES = 3
BACKOFF_BASE = 0.5
BACKOFF_FACTOR = 2.0
BACKOFF_JITTER = 0.2

# ----------------------------
# Helpers
# ----------------------------
def load_json(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def check_fw_version(v, cmp_to="7.8.0"):
    def parse(s): return tuple(int(x) for x in s.split("."))
    return parse(v) >= parse(cmp_to)

def gen_username():
    return "usermgmt_" + secrets.token_hex(3)

def gen_password(length=16):
    chars = string.ascii_letters + string.digits + "!@#$%^&*()-_=+"
    while True:
        p = ''.join(secrets.choice(chars) for _ in range(length))
        if (any(c.islower() for c in p) and any(c.isupper() for c in p)
                and any(c.isdigit() for c in p) and any(c in "!@#$%^&*()-_=+" for c in p)):
            return p

async def backoff_sleep(attempt):
    base = BACKOFF_BASE * (BACKOFF_FACTOR ** (attempt - 1))
    jitter = random.uniform(-BACKOFF_JITTER, BACKOFF_JITTER)
    await asyncio.sleep(max(0, base + jitter))

def write_failed(entry):
    os.makedirs(os.path.dirname(FAILED_LOG), exist_ok=True)
    with portalocker.Lock(FAILED_LOG, mode="a", timeout=5) as fh:
        fh.write(json.dumps(entry) + "\n")

def get_content_type_token(version_map, fw_version):
    token = version_map.get(fw_version)
    if token is None:
        raise KeyError(f"Firmware version '{fw_version}' not found in {VERSION_FILE}")
    return token

# ----------------------------
# Curl command wrappers
# ----------------------------
async def run_cmd(cmd):
    proc = await asyncio.create_subprocess_exec(*cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE)
    out, err = await proc.communicate()
    return proc.returncode, (out.decode() + err.decode()).strip()

async def check_webserver_curl(base_url, insecure):
    url = f"{base_url}/"
    cmd = ["curl", "-s", "-o", "/dev/null", "-w", "%{http_code}", "-I", url]
    if insecure: cmd.insert(1, "-k")
    _, out = await run_cmd(cmd)
    return out.strip()

async def curl_auth(base_url, admin_user, admin_pass, ct, insecure):
    url = f"{base_url}/auth/session"
    cmd = ["curl", "-s", "-S", "-i", "-X", "POST",
           "-H", f"Content-Type: {ct}",
           "-u", f"{admin_user}:{admin_pass}", url]
    if insecure: cmd.insert(1, "-k")
    rc, out = await run_cmd(cmd)
    for line in out.splitlines():
        if "SESSION_ID=" in line:
            return line.split("SESSION_ID=")[1].split(";")[0].strip()
    raise RuntimeError(f"REST login failed (rc={rc}): {out}")

async def curl_post_role(base_url, sid, ct, role, insecure):
    url = f"{base_url}/roles"
    payload = json.dumps({"roleId": role})
    cmd = ["curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
           "-X", "POST", "-H", f"Content-Type: {ct}",
           "-H", f"Cookie: SESSION_ID={sid}", url, "-d", payload]
    if insecure: cmd.insert(1, "-k")
    _, out = await run_cmd(cmd)
    return int(out.strip() or -1)

async def curl_put_rolefile(base_url, sid, ct_file, path, role, insecure):
    url = f"{base_url}/roles/{role}/resources"
    cmd = ["curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
           "-X", "PUT", "-H", f"Content-Type: {ct_file}",
           "-H", f"Cookie: SESSION_ID={sid}", url, "--data-binary", f"@{path}"]
    if insecure: cmd.insert(1, "-k")
    _, out = await run_cmd(cmd)
    return int(out.strip() or -1)

async def curl_post_user(base_url, sid, ct, user, pwd, role, insecure):
    url = f"{base_url}/users"
    payload = json.dumps({"userId": user, "role": role, "password": pwd})
    cmd = ["curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
           "-X", "POST", "-H", f"Content-Type: {ct}",
           "-H", f"Cookie: SESSION_ID={sid}", url, "-d", payload]
    if insecure: cmd.insert(1, "-k")
    _, out = await run_cmd(cmd)
    return int(out.strip() or -1)

async def curl_get_users(base_url, sid, ct, insecure):
    url = f"{base_url}/users"
    cmd = ["curl", "-s", "-i", "-X", "GET",
           "-H", f"Content-Type: {ct}",
           "-H", f"Cookie: SESSION_ID={sid}", url]
    if insecure: cmd.insert(1, "-k")
    _, out = await run_cmd(cmd)
    return out

# ----------------------------
# LunaSH (SSH) functions
# ----------------------------
async def connect_password_only(host, port, username, password):
    try:
        return await asyncssh.connect(
            host,
            port=port,
            username=username,
            password=password,
            known_hosts=None,
            client_keys=None,
            allow_agent=False,
            look_for_keys=False
        )
    except TypeError:
        return await asyncssh.connect(
            host,
            port=port,
            username=username,
            password=password,
            allow_agent=False,
            look_for_keys=False
        )

async def lunash_setup(hsm, ssh_user, ssh_pass, role_file, user, pwd):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    local_role = os.path.join(ROLES_DIR, role_file)
    role_name = os.path.splitext(os.path.basename(local_role))[0]
    remote_role = f"/tmp/{os.path.basename(local_role)}"
    async with await connect_password_only(host, port, ssh_user, ssh_pass) as conn:
        async with conn.start_sftp_client() as sftp:
            await sftp.put(local_role, remote_role)
        steps = [
            (f"user role import {role_name} {remote_role}", "role import"),
            (f"user add {user} -password {pwd}", "user add"),
            (f"user role add {user} {role_name}", "assign role"),
        ]
        for cmd, label in steps:
            res = await conn.run(cmd, check=False, term_type='xterm')
            print(f"[{hsm.get('id')}] {label}: {'OK' if res.exit_status == 0 else 'FAIL'}")
        res = await conn.run(f"user password {user}", input=(pwd + "\n" + pwd + "\n"),
                             check=False, term_type='xterm')
        print(f"[{hsm.get('id')}] set password: {'OK' if res.exit_status == 0 else 'FAIL'}")
        out = (await conn.run("user list", check=False, term_type='xterm')).stdout
        return user in out

async def lunash_check_webserver(hsm, ssh_user, ssh_pass):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    base = hsm.get("rest_url") or f"https://{host}:8443"
    try:
        code = await check_webserver_curl(base, False)
        if code.startswith("2"):
            print(f"[{hsm.get('id')} | {host}] webserver: running (REST)")
            return True
    except Exception:
        pass
    try:
        async with await connect_password_only(host, port, ssh_user, ssh_pass) as conn:
            res = await conn.run("webserver show", check=False, term_type='xterm')
            out = (res.stdout or "").lower()
            if ("status" in out) and ("running" in out):
                print(f"[{hsm.get('id')} | {host}] webserver: running (LunaSH)")
                return True
            return False
    except Exception as e:
        print(f"[{hsm.get('id')} | {host}] webserver check error: {e}")
        return False

async def test_ssh_one(hsm, ssh_user, ssh_pass):
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 22))
    try:
        async with await connect_password_only(host, port, ssh_user, ssh_pass) as conn:
            ulist = await conn.run("user list", check=False, term_type='xterm')
            print(f"[{hsm.get('id')} | {host}] SSH OK, user list snippet:\n{(ulist.stdout or '')[:200]}")
            return True, None
    except Exception as e:
        return False, str(e)

# ----------------------------
# Orchestration per HSM
# ----------------------------
