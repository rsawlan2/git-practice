#!/usr/bin/env python3
"""
user_mgmt_rest_using_your_api.py

Full REST automation using the APIs you provided in screenshots.
- CLI matches v3 SSH spec: --hsm-id, --env, --sshuser, --sshpassword, --newuser
- Auth: POST /auth/session (Basic Auth) -> SESSION_ID cookie
- Cert flow: /api/lunasa/webServer/csr, /api/lunasa/webServer/certificate, /api/lunasa/services/webserver/actions/restart
- Upload role file: POST /users/{admin}/files (multipart; documented)
- Import role: tries documented likely endpoints (ordered conservative attempts)
- Create user: POST /api/lunasa/users
- Verify/list: GET /api/lunasa/users
- Assign role: tries documented assign endpoints
- Stores generated password in resources/user_passwords.json under "rest"
- TLS options: --no-verify, --cacert, --client-cert
"""

import argparse
import json
import os
import datetime
import secrets
import string
import tempfile
import re
import getpass
from typing import Optional, Tuple

import requests

# -------------------- Constants / Paths --------------------
RES_DIR = "resources"
HSM_FILE = os.path.join(RES_DIR, "hsm_mapping.json")    # must exist
PW_STORE = os.path.join(RES_DIR, "user_passwords.json")
os.makedirs(RES_DIR, exist_ok=True)

FIXED_ROLE_NAME = "user_mgmt_role"
DEFAULT_CONTENT_TYPE = "application/vnd.safenetinc.lunasa+json;version=10"
UPLOAD_CONTENT_TYPE = "application/vnd.safenetinc.lunasa+multipart;version=10"
CERT_UPLOAD_CT = "application/vnd.safenetinc.lunasa+octet-stream;version=10"

ROLE_DEFINITIONS = {
    "7.3": ["user list","user add","user delete","user enable","user disable","user password","user role add","user role delete","user role clear","user role list","user role import"],
    "7.7": ["user list","user add","user delete","user enable","user disable","user password","user radiusAdd","user role add","user role delete","user role list","user role import"],
    "7.9": ["user list","user add","user delete","user enable","user disable","user password","user radiusAdd","user radiusDelete","user role add","user role delete","user role list","user role import"]
}
FALLBACK_ROLE = ["user list","user add","user delete","user password","user role list","user role import"]

ENV_USER_MAP = {
    "DEV": "svc_at48994_usrmgt",
    "TE1": "svc_at48993_usrmgt",
    "TE2": "svc_at48992_usrmgt",
    "PROD": "svc_at49008_usrmgt"
}

# -------------------- Helpers --------------------
def _generate_temp_password(length: int = 16) -> str:
    alphabet = string.ascii_letters + string.digits + "._-"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def _save_password_for_user(username: str, password: str, backend: str = "rest") -> None:
    data = {}
    if os.path.exists(PW_STORE):
        try:
            with open(PW_STORE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            data = {}
    if username not in data:
        data[username] = {}
    data[username][backend] = {"password": password, "created_at": datetime.datetime.utcnow().isoformat() + "Z"}
    tmp = PW_STORE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, PW_STORE)
    try:
        os.chmod(PW_STORE, 0o600)
    except Exception:
        pass

def json_to_flat_str(obj) -> str:
    parts = []
    if isinstance(obj, dict):
        for k, v in obj.items():
            parts.append(str(k))
            parts.append(json_to_flat_str(v))
    elif isinstance(obj, list):
        for it in obj:
            parts.append(json_to_flat_str(it))
    else:
        parts.append(str(obj))
    return " ".join([p for p in parts if p is not None and p != ""])

# -------------------- HSM mapping loader --------------------
def load_hsm(hsm_id: str) -> dict:
    if not os.path.exists(HSM_FILE):
        raise SystemExit(f"[ERROR] Missing mapping file: {HSM_FILE}")
    with open(HSM_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for h in data.get("hsms", []):
        if h.get("id") == hsm_id:
            return h
    raise SystemExit(f"[ERROR] HSM id '{hsm_id}' not found in mapping.")

# -------------------- REST primitives (your APIs) --------------------
def rest_login(session: requests.Session, base_url: str, admin_user: str, admin_pwd: str, headers: dict, verify: bool = False, client_cert: Optional[str] = None) -> Tuple[bool,str]:
    url = base_url.rstrip("/") + "/auth/session"
    try:
        resp = session.post(url, auth=(admin_user, admin_pwd), headers=headers, timeout=20, verify=verify, cert=client_cert)
    except requests.RequestException as e:
        return False, f"Login request failed: {e}"
    if resp.status_code not in (200,201):
        return False, f"Login failed: {resp.status_code}: {resp.text[:400]}"
    return True, "Login successful"

def detect_rest_version(session: requests.Session, base_url: str, headers: dict, timeout: int = 8, verify: bool = False) -> str:
    probes = ["/api/lunasa/version","/api/lunasa/system/version","/api/v1/version","/api/lunasa/webServer","/api/lunasa/summary","/api/lunasa/system","/api/v1/system/status","/api/v1/info","/auth/session"]
    for p in probes:
        try:
            resp = session.get(base_url.rstrip("/") + p, headers=headers, timeout=timeout, verify=verify)
        except requests.RequestException:
            continue
        text = ""
        try:
            j = resp.json(); text = json_to_flat_str(j)
        except Exception:
            text = resp.text or ""
        m = re.search(r"(\d+)\.(\d+)", text)
        if not m:
            continue
        major, minor = int(m.group(1)), int(m.group(2))
        if major == 7 and minor in (3,4,5,6):
            return "7.3"
        if major == 7 and minor in (7,8):
            return "7.7"
        if (major == 7 and minor >= 9) or major >= 8:
            return "7.9"
        return ""
    return ""

def rest_upload_file(session: requests.Session, base_url: str, admin_user: str, local_path: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool, Optional[dict], str]:
    # documented upload endpoint from your screenshots: POST /users/{admin}/files
    url = base_url.rstrip("/") + f"/users/{admin_user}/files"
    upload_headers = dict(headers)
    upload_headers["Content-Type"] = UPLOAD_CONTENT_TYPE
    try:
        with open(local_path, "rb") as fh:
            files = {"file": (os.path.basename(local_path), fh)}
            resp = session.post(url, headers=upload_headers, files=files, timeout=60, verify=verify, cert=client_cert)
    except FileNotFoundError:
        return False, None, f"Local file not found: {local_path}"
    except requests.RequestException as e:
        return False, None, f"Upload failed: {e}"
    if resp.status_code not in (200,201):
        return False, None, f"{resp.status_code}: {resp.text[:800]}"
    try:
        return True, resp.json(), "Upload success"
    except Exception:
        return True, {"raw": resp.text}, "Upload success (no json)"

def rest_try_import(session: requests.Session, base_url: str, admin_user: str, upload_info: dict, role_name: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool,str]:
    # tries the documented/likely import endpoints (ordered)
    file_id = None
    file_name = None
    if isinstance(upload_info, dict):
        for k in ("id","fileId","file_id"):
            if k in upload_info:
                file_id = upload_info.get(k)
        for k in ("filename","name"):
            if k in upload_info:
                file_name = upload_info.get(k)
    if not file_id and not file_name and "raw" in upload_info:
        m = re.search(r"([a-zA-Z0-9_\-\.]+\.txt)", upload_info.get("raw",""))
        if m: file_name = m.group(1)

    base = base_url.rstrip("/")
    attempts = [
        (f"{base}/api/lunasa/roles/import", {"file": file_id or file_name, "role": role_name}),
        (f"{base}/api/lunasa/roles/actions/import", {"file": file_id or file_name, "role": role_name}),
        (f"{base}/api/lunasa/users/{admin_user}/files/{file_id or file_name}/actions/import", {"role": role_name}),
        (f"{base}/api/lunasa/users/{admin_user}/files/actions/import", {"file": file_id or file_name, "role": role_name}),
        (f"{base}/api/lunasa/myfile/actions/import", {"file": file_id or file_name, "role": role_name})
    ]
    for url, payload in attempts:
        try:
            resp = session.post(url, json=payload, headers=headers, timeout=30, verify=verify, cert=client_cert)
        except requests.RequestException:
            continue
        if resp.status_code in (200,201):
            return True, f"Imported via {url}"
    return False, "No import endpoint succeeded (checked known locations)"

def rest_create_user(session: requests.Session, base_url: str, userid: str, password: str, role: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool,str]:
    url = base_url.rstrip("/") + "/api/lunasa/users"
    payload = {"userid": userid, "role": role, "password": password}
    try:
        resp = session.post(url, json=payload, headers=headers, timeout=30, verify=verify, cert=client_cert)
    except requests.RequestException as e:
        return False, f"Create user request failed: {e}"
    if resp.status_code in (200,201):
        return True, "User created"
    # common "409" or detail in body returned
    return False, f"{resp.status_code}: {resp.text[:800]}"

def rest_list_users(session: requests.Session, base_url: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool, Optional[object], str]:
    url = base_url.rstrip("/") + "/api/lunasa/users"
    try:
        resp = session.get(url, headers=headers, timeout=15, verify=verify, cert=client_cert)
    except requests.RequestException as e:
        return False, None, f"List users request failed: {e}"
    if resp.status_code != 200:
        return False, None, f"{resp.status_code}: {resp.text[:800]}"
    try:
        return True, resp.json(), "OK"
    except Exception:
        return False, None, "Invalid JSON from users endpoint"

def rest_try_assign_role(session: requests.Session, base_url: str, userid: str, role: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool,str]:
    base = base_url.rstrip("/")
    attempts = [
        (f"{base}/api/lunasa/roles/assign", {"userId": userid, "role": role}),
        (f"{base}/api/lunasa/users/{userid}/roles", {"role": role}),
        (f"{base}/api/lunasa/users/{userid}/role", {"role": role}),
        (f"{base}/api/lunasa/users/{userid}/roles/assign", {"role": role})
    ]
    for url, payload in attempts:
        try:
            resp = session.post(url, json=payload, headers=headers, timeout=20, verify=verify, cert=client_cert)
        except requests.RequestException:
            continue
        if resp.status_code in (200,201):
            return True, f"Assigned via {url}"
    return False, "No assign endpoint succeeded"

# Certificate helpers (the endpoints you provided)
def rest_generate_csr(session: requests.Session, base_url: str, headers: dict, payload: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool,str]:
    url = base_url.rstrip("/") + "/api/lunasa/webServer/csr"
    try:
        resp = session.post(url, json=payload, headers=headers, timeout=30, verify=verify, cert=client_cert)
    except requests.RequestException as e:
        return False, f"CSR failed: {e}"
    if resp.status_code not in (200,201):
        return False, f"CSR failed: {resp.status_code}: {resp.text[:800]}"
    try:
        j = resp.json()
        for k in ("csr","certificateRequest","csrPem"):
            if k in j: return True, j[k]
        return True, json.dumps(j)
    except Exception:
        return True, resp.text or ""

def rest_upload_certificate(session: requests.Session, base_url: str, cert_path: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool,str]:
    url = base_url.rstrip("/") + "/api/lunasa/webServer/certificate"
    upload_headers = dict(headers)
    upload_headers["Content-Type"] = CERT_UPLOAD_CT
    try:
        with open(cert_path, "rb") as fh:
            resp = session.put(url, headers=upload_headers, data=fh.read(), timeout=60, verify=verify, cert=client_cert)
    except FileNotFoundError:
        return False, f"Cert file not found: {cert_path}"
    except requests.RequestException as e:
        return False, f"Upload cert failed: {e}"
    if resp.status_code not in (200,201):
        return False, f"{resp.status_code}: {resp.text[:800]}"
    return True, "Certificate uploaded"

def rest_restart_webserver(session: requests.Session, base_url: str, headers: dict, verify: bool=False, client_cert: Optional[str]=None) -> Tuple[bool,str]:
    url = base_url.rstrip("/") + "/api/lunasa/services/webserver/actions/restart"
    try:
        resp = session.post(url, headers=headers, timeout=30, verify=verify, cert=client_cert)
    except requests.RequestException as e:
        return False, f"Restart failed: {e}"
    if resp.status_code not in (200,201):
        return False, f"{resp.status_code}: {resp.text[:800]}"
    return True, "Restart requested"

# -------------------- Main --------------------
def main():
    parser = argparse.ArgumentParser(description="REST user mgmt using your APIs (upload/import/create/assign)")
    parser.add_argument("--hsm-id", required=True, help="HSM id in resources/hsm_mapping.json")
    parser.add_argument("--env", required=True, choices=["DEV","TE1","TE2","PROD"], type=str.upper, help="Environment")
    parser.add_argument("--sshuser", default="admin", help="Admin username (default admin)")
    parser.add_argument("--sshpassword", help="Admin password (prompt if missing)")
    parser.add_argument("--newuser", help="Override new user name (optional)")
    parser.add_argument("--role-file", help="Local role .txt to upload (optional). If omitted, script builds from role-lines for detected version.")
    parser.add_argument("--do-cert", action="store_true", help="Run CSR generation (writes CSR to temp) - stop for manual signing and re-run to upload cert.")
    parser.add_argument("--csr-cn", help="CN for CSR (default: HSM host)", default=None)
    parser.add_argument("--no-verify", action="store_true", help="Don't verify TLS (lab only)")
    parser.add_argument("--cacert", help="Path to CA bundle to verify server")
    parser.add_argument("--client-cert", help="Path to client cert (PEM) if server requires mutual TLS")
    args = parser.parse_args()

    env = args.env.upper()
    if args.newuser:
        new_user = args.newuser
    else:
        new_user = ENV_USER_MAP.get(env)
        if not new_user:
            raise SystemExit(f"[ERROR] unsupported env {env}")
    admin_user = args.sshuser
    admin_pwd = args.sshpassword or getpass.getpass(f"Password for {admin_user}@HSM (REST): ")

    hsm = load_hsm(args.hsm_id)
    host = hsm.get("ipAddress") or hsm.get("host")
    port = int(hsm.get("port", 8443))
    base_url = f"https://{host}:{port}"

    verify = True
    if args.no_verify:
        verify = False
    if args.cacert:
        verify = args.cacert
    client_cert = args.client_cert if args.client_cert else None

    session = requests.Session()
    session.headers.update({"Content-Type": DEFAULT_CONTENT_TYPE})

    ok, msg = rest_login(session, base_url, admin_user, admin_pwd, headers=session.headers, verify=verify, client_cert=client_cert)
    if not ok:
        print(f"[ERROR] login failed: {msg}")
        return
    print("[INFO] REST login successful")

    # optional cert CSR (stops for manual signing)
    if args.do_cert:
        cn = args.csr_cn or host
        payload = {"keyType":"rsa","keySize":2048,"cn":cn}
        ok_csr, csr_text = rest_generate_csr(session, base_url, headers=session.headers, payload=payload, verify=verify, client_cert=client_cert)
        if not ok_csr:
            print(f"[ERROR] CSR generation failed: {csr_text}")
            return
        csr_file = os.path.join(tempfile.gettempdir(), f"{host}.csr.pem")
        with open(csr_file, "w", encoding="utf-8") as f:
            f.write(csr_text)
        print(f"[INFO] CSR written to {csr_file}. Sign it with CA, then run script with --role-file <rolefile> and cert upload will be used.")
        return

    version_tag = detect_rest_version(session, base_url, headers=session.headers, timeout=8, verify=verify)
    role_lines = ROLE_DEFINITIONS.get(version_tag, FALLBACK_ROLE)
    role_filename = f"user_mgmt_role_{version_tag}.txt" if version_tag else "user_mgmt_role_fallback.txt"
    print(f"[SUMMARY] REST version: {version_tag or 'fallback'} ; role filename (informational): {role_filename}")

    # build or accept provided role file
    if args.role_file:
        local_role = args.role_file
        if not os.path.exists(local_role):
            print(f"[ERROR] role file not found: {local_role}")
            return
    else:
        local_role = os.path.join(tempfile.gettempdir(), role_filename)
        with open(local_role, "w", encoding="utf-8", newline="\n") as f:
            for l in role_lines:
                f.write(l.rstrip() + "\n")
        print(f"[INFO] built temp role file: {local_role}")

    # upload role file
    ok_up, upload_info, up_msg = rest_upload_file(session, base_url, admin_user, local_role, headers=session.headers, verify=verify, client_cert=client_cert)
    if not ok_up:
        print(f"[ERROR] role upload failed: {up_msg}")
        # we choose to continue and try create user (or you can exit)
    else:
        print(f"[INFO] role uploaded: {upload_info} ; attempting import via REST endpoints...")
        ok_imp, imp_msg = rest_try_import(session, base_url, admin_user, upload_info or {}, FIXED_ROLE_NAME, headers=session.headers, verify=verify, client_cert=client_cert)
        if ok_imp:
            print(f"[INFO] role import success: {imp_msg}")
        else:
            print(f"[WARN] REST import attempts failed: {imp_msg}\n[WARN] If REST import not supported on this HSM/version, fallback to SSH import is required.")

    # create user
    new_pw = _generate_temp_password()
    ok_create, create_msg = rest_create_user(session, base_url, new_user, new_pw, FIXED_ROLE_NAME, headers=session.headers, verify=verify, client_cert=client_cert)
    if ok_create:
        _save_password_for_user(new_user, new_pw, backend="rest")
        print(f"[INFO] user created: {new_user} (password saved)")
    else:
        print(f"[WARN] create user returned non-success: {create_msg}")

    # verify and assign if needed
    ok_list, users_data, list_msg = rest_list_users(session, base_url, headers=session.headers, verify=verify, client_cert=client_cert)
    if not ok_list:
        print(f"[ERROR] could not list users: {list_msg}")
        return

    found = False; role_ok = False
    try:
        if isinstance(users_data, list):
            for u in users_data:
                uid = u.get("userid") or u.get("userId") or u.get("id")
                if uid == new_user:
                    found = True
                    r = u.get("role") or u.get("roles")
                    if isinstance(r, list):
                        role_ok = FIXED_ROLE_NAME in r
                    else:
                        role_ok = (r == FIXED_ROLE_NAME)
                    break
        elif isinstance(users_data, dict):
            for key in ("users","data","result"):
                if key in users_data and isinstance(users_data[key], list):
                    for u in users_data[key]:
                        uid = u.get("userid") or u.get("userId") or u.get("id")
                        if uid == new_user:
                            found = True
                            r = u.get("role") or u.get("roles")
                            if isinstance(r, list):
                                role_ok = FIXED_ROLE_NAME in r
                            else:
                                role_ok = (r == FIXED_ROLE_NAME)
                            break
                    if found: break
    except Exception:
        pass

    if found and role_ok:
        print(f"[INFO] Verified {new_user} exists with role {FIXED_ROLE_NAME}")
    elif found and not role_ok:
        print(f"[WARN] {new_user} exists but role missing â€” attempting assign")
        ok_assign, assign_msg = rest_try_assign_role(session, base_url, new_user, FIXED_ROLE_NAME, headers=session.headers, verify=verify, client_cert=client_cert)
        if ok_assign:
            print(f"[INFO] role assigned: {assign_msg}")
        else:
            print(f"[ERROR] role assign attempts failed: {assign_msg}")
    else:
        print(f"[ERROR] user {new_user} not found after create attempt. Response: {list_msg}")

    print(f"[SUMMARY] Completed REST provisioning for HSM {args.hsm_id} ({env}).")
    return

if __name__ == "__main__":
    main()
